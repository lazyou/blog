## 第一部分 JavaScript 语言核心

## 第2章 词法结构
* 2.0 简介
    * **词法结构**是一套基础性规则， 用来描述如何使用这门语言来编写程序。
* 2.1 字符集
    * `JavaScript` 程序使用`Unicode` 字符集编写的。
    * 区分大小写（另注：HTML 不区分大小写， XHTML 区分大小写）。
    * 空格、 换行符 和 格式控制符： 
        * 空格--`'\u0020'`, 水平制表符`'\u0009'` ... 等。
        * 回车符加换行符一起被解析为一个**单行结束符**。 
    * `Unicode` 转移序列， 因为有的软硬件不能显示或输入 `Unicode` 字符全集： `'caf\u00e9'` == `'café'`
* 2.2 注释
    * 单行注释： `//`。
    * 多行注释： `/* ... */`。
* 2.3 直接量
    * 程序中**直接使用的数据值**就叫做直接量。
* 2.4 标识符和保留字
    * **标识符** 就是一个名字。
    * 标识符**必须**以字母、 下划线、 美元符 开始。
    * **保留字**： `JavaScript` 的关键字， 不能被用做标识符。
* 2.5 可选的分号
    * **分号**分割语句不是必须的， 除非影响代码的可读性和简洁性。


## 第3章 类型、值和变量
* **3.0 简介**
    * 能够表示并操作的值的类型称作**数据类型**
    * 数据类型分为两类： 
        * **原始类型**： 数字、 字符串 和 布尔值。（**特殊原始值**: `null 空` 和 `undefined 未定义`）。
        * **对象类型**： 每个属性都由 *键/值对* 构成。 （**特殊对象**： 全局对象、数组、函数）。
    * 函数： 是特殊对象。 
        * 被 `new` 运算符建立对象的函数称为**构造函数**。
        * 每个**构造函数**定义了一**类**对象--由构造函数初始化的对象组成的集合。
        * 除了`Array类` 和 `Function类`意外， JS 语言核心海定义了其他三种游有用的类： `Date / RegExp / Error`。 （简单点讲， 就是可以被 `new` 成对象的类型。）
    * 数据类型同样可分为 *可变类型 mutable* 和 *不可变类型 immutable*： 对象是可变类型
    * **词法作用域**： 
        * 不在任何*函数内*声明的变量称作**全局变量**, 它在 JS 程序中的任何地方都是可见的。
        * 在*函数内*声明的变量具有**函数作用域**。
* 3.1 数字
    * `JavaScript` **不区分**整数值和浮点数值。
    * 十六进制： `0x`或 `0X` 为前缀。
    * 八进制： `0` 为前缀。
    * `Math`对象。
    * `Date()`构造函数。
* 3.2 文本
    * **字符串**是一组由16位值组成的不可变的**有序序列**， 每个字符串通常来自于 `Unicode` 字符集。
    * 转义字符： 反斜杠`\`后面加一个字符。（`\t`: 水平制符; `\n`: 换行符 ...）
    * 字符串的方法： `s.chatAt; s.substring; s.slice; s.indexOf ...`
    * 模式匹配： `RegExp()`构造函数来创建表示文本匹配模式的对象。
        * 这些模式称为**正则表达式**。
        * JS 采用`Perl`中的正则表达式语法。
* 3.3 布尔值
    * 只有两个值： `true` 和 `false`。
    * JS 的任何值都可以被转为布尔。
    * `undefined、 null、 0、 -0、 NaN、 ""` 都会被转成 `false`。
* 3.4 null和undefined
    * `typeof null` 返回字符串 "object"， 也就是说 `null`是特殊的对象值。
* 3.5 **全局对象**
    * JS解释器启动的时候就创建。
    * 全局属性： `undefined Infinity NaN ...` 
    * 全局函数： `isNaN() parseInt() eval() ...`
    * 构造函数： `Date() RegExp() String() Object() Array()`
    * 全局对象： `Math JSON`
    * `Window`对象充当了**全局对象**
* 3.6 包装对象
    * `var s="hello"; s.substring(xxx)`; 字符串既然不是对象， 为什么会有属性？
    * 答： 只要引用了字符串s的属性，JS就会将字符串值通过调用`new String(s)`的方式转为对象。
    * 存取字符串、 数字或布尔值的属性*时临时创建的对象*称做**包装对象**。（偶尔用来区分 *字符串和字符串对象*、 *数字和数值对象*、 *布尔值和布尔对象*）
    * `String() 、Number()、 Boolean()`构造函数可以用来显示创建**包装对象**。
* 3.7 不可变的原始值和可变的对象引用
    * 对象都是**引用类型**
    * 对象值都是**引用**
    * 对象或数组赋值给一个变量，仅仅是赋值引用值，对象本身没有复制一次。（需要**深度拷贝**）
    * 对象或数组做比较，必须比较他们的每个属性。（深度比较）
* 3.8 类型转换
    * `==` 和 `===` 的区别。（推荐使用 `===` 做比较）
    * 显示类型转换： 使用函数`Boolean()、 Number()、 String()、 Object()`。
        * 除了`null` 和 `undefined` 之外任何值都由`toString()`方法， 通常与`String()` 函数的结果一致。（转为字符串类型）
    * 对象转原始值： 
        * 所有的对象继承了两个转换方法： `toString()` 和 `valueOf()`
        * `toString()`： 对象到字符串。
        * `valueOf()`： 对象到数字。
        * 对象到字符串转换步骤： 优先 `toString()`, 没有则调用 `valueOf()`,不然就异常。
        * 对象到数字转换步骤： 优先 `valueOf()`, 没有则调用 `toString()`,不然就异常。
* 3.9 变量声明
    * 使用关键字 `var` 来声明。
    * 变量没有制定初始值， 它的初始值就是 `undefined`。
* 3.10 变量作用域
    * *全局作用域* 和 *局部作用域*（函数作用域）
    * 局部作用域**优先级**高于全局作用域
    * 声明全局变量*可以不用* `var`。（**但**不代表不用`var`声明的都是全局变量）
    * JS没有*块级作用域*，而是使用**函数作用域**。
    * JS 会自动**声明提前** -- 变量在声明之前可以使用， JS函数里声明的所有变量（但不包括赋值）都会被”提前“至函数提的顶部。
    ```javascript
    var scope = "global";
    function f() {
        console.log(scope); // undefined 而非 global
        var scope = "local"; // 赋值
        console.log(scope); // local
    }

    变量提前 -- 等价于如下
    function f() {
        var scope; // 函数顶部声明了局部变量
        console.log(scope); // undefined 而非 global
        scope = "local"; // 初始化赋值
        console.log(scope); // local
    }
    ```
    * 所以先声明后使用是一个好习惯
    * **作用域链**
        * **全局变量**在程序中*始终*是有定义的.
        * **局部变量**在声明它的函数体内*以及其所嵌套的函数内*始终是有定义的.
        * 作用域链
            * 把*局部变量*看做是自定义实现的对象属性:
                * 每一段JS代码(全局代码或函数)都有一个与之关联的**作用域链**.
                * 这个作用域链是一个对象列表或者链表, 这组对象定义了这段代码"作用域中"的变量.
                * 当JS查找变量x的值的时候(此过程乘坐"变量解析"), 它会从链中的第一个对象开始查找, 有x则使用, 无责继续查找链上的下一个对象, 以此类推.
                * 如果作用域链上没有任何一个对象属性x, 抛出引用错误异常.
            * 在JS最顶层代码中(不包含在任何函数定义内的代码), *作用域链*由一个全局对象组成:
                * 在不包含嵌套的函数体内, *作用域链*上有两个对象: 第一个是定义函数参数和局部变量的对象, 第二个是全局对象;
                * 在一个嵌套的函数体内, *作用域链*上至少有三个对象: 
                    * 当定义一个函数时, 它实际上保存一个*作用域链*; 
                    * 当调用这个函数式, 它创建一个新的对象来存储它的局部变量, 并将这个对象添加至保存的那个*作用域链*上, 同时创建一个新的更长的表示函数调用作用域的"链".
                    * 对于**嵌套函数**来讲, 每次调用外部函数时, 内部函数又会重新定义一遍. 因为每次调用外部函数的时候, 作用域链都是不同的.
                    * **总之, 嵌套函数的作用域链是最难理解同时也是最重要的! 有助于理解闭包! TODO:看不懂嵌套函数的作用域链.**



## 第4章 表达式和运算符
* 4.0 简介
    * **表达式**是JS中的一个*短语*, JS解释器会将其计算成一个结果。
    * 将*简单表达式*组成*复杂表达式*最常用的方法就是使用**运算符**。
* 4.1 原始表达式
    * **原始表达式**是*表达式*的最小单位--它们不再包含其他表达式。
    * JS中的原始表达式包含*常量、直接量、关键字、变量*。（不过好像很少直接使用原始表达式）
    * 例子：
    ```
    1.23 // 直接量
    true // 关键字
    i    // 变量
    ```
* 4.2 对象和数组的初始化表达式
    * 对象和数组初始化表达式实际上是一个*新创建的对象和数组*。
    * ”对象直接量“和”数组直接量“*不是原始表达式*， 因为它们所包含的成员或元素都是*子表达式*。
    * 数组初始化表达式是通过一对方括号和其内的逗号隔开的列表构成的， 初始化结果就是一个新创建的数组。 （`[]; [1+2, 3+4]`）
    * 数组表达式可以嵌套。（多维数组 `[[1, 2], [3, 4]]`）
    * JS对数组初始化表达式进行求值的时候， 数组初始化表达式中的-元素表达式-也会各自计算一次。
    *  数组直接量中的都要之间的元素可以省略，*省略的空位会填充undefined*。(`[1,,,3]`相当于`[1, undefined, undefined, 3]`)
    * 对象表达式也可以嵌套， 在初始化时也会各自计算。（`{o: {x:1, y:2}}`）
* 4.3 函数定义表达式
    * 函数定义表达式定义一个JS函数， *表达式的值*是这个新定义的函数。
* 4.4 属性访问表达式
    * 属性访问表达式可得到一个对象属性或一个数组元素的值。
    * JS为属性访问定义两种方法： 访问的属性不存在则值为 `undefined`。
    ```
    expression.identifier
    expression[identifier]
    ```
* 4.5 调用表达式
    * 调用表达式是一种调用（或执行）函数或方法的语法表示。
    * 函数名+括号。
* 4.6 对象创建表达式
    * 对象创建表达式创建一个对象*并*调用一个函数(**构造函数**)初始化新对象的属性.
    ```
    new Object();
    new Point(2, 3);
    ```
    * 如果对象创建表达式不需要传入参数给构造函数的话, 空括号可以省略.
    ```
    new Object;
    new Point;
    ```
* 4.7 运算符概述
    * 运算符用于算数表达式 / 比较表达式等等.
    * 大多数运算符都是由*标点符号*表示, 例如 `+` / `-` / `-`.
    * 一些运算符则是由*关键字*表示, 例如 `delete` 和 `instanceof`.
    * 运算符的优先级: TODO: 补充个截图比较直观.
    1. 操作数的个数:
        * 一元运算符: `-x` (求负数)
        * 二元运算符: `x+y`
        * 三元运算符: `?:`
    2. 操作数类型和结果类型:
        * 一般由运算符决定结果: 例如 `'3' * '5'` 得到 15(整型) , 而 `'3' + '5'` 得到 35(字符串).
    3. 左值:
        * 指的是"表达式只能出现在赋值运算符的*左侧*". `a = 1;`
        * JS中变量 / 对象属性 和 数组元素均是左值. 
    4. 运算符的副作用:
        * `++ / --` 此类运算符包含隐式赋值, 使得使用这个变量的表达式都会受影响.
        * `delete` 运算符也有副作用, 删除对象属性后访问得到是`undefined`, 影响到了对应相关的使用.
    5. 运算符优先级:
        * `typeof`是优先级*最高*的运算符之一.
        * 不确定优先级的话, 可以使用括号来强制指定运算次序. (表示一直这样!)
    6. 运算符的结合性:
    7. 运算顺序:
        * Js总是从**左到右顺序**来计算表达式的.
        * 只有在任何一个表达式具有副作用而影响到其他表达式的时候, 其求职顺序才会看上去有所不同.
* 4.8 算术表达式
    * 基本算数运算符是`+ - * / % 加减乘除余`。
    * 无法转为数字的操作数都转换为`NaN`值。（除了加法会被转为字符串拼接）
    * 除数为0的运算结果为正无穷大或负无穷大。 `0/0`的结果是`NaN`。
    1. "+"运算符
        * 二元加法运算符可以对两个数字做**加法**， 也可以做**字符串连接**操作。
        * *优先*考虑字符串连接，其中一个操作数是字符串，另一个操作数也将会转为字符串。
        * 如果一个*操作数是对象*，则会遵循对象到*原始值*的转换规则转换为*原始类值*： 日期对象通过`toString()`方法转换， 其他对象通过`valueOf()`方法转换（如果它返回一个原始值的话）。
        * 由于多数对象都不具备可用的`valueOf()`方法，因此它们会通过`toString()`方法来执行抓换。 `1 + {}` 得到 `"1[object Object]"`
    2. 一元算术运算符
        * 一元加法： +
        * 一元减法： -
        * 递增： ++ （运算符在操作数之前称为*前增量运算符*，在操作数之后称为*后增量运算符*）
        * 递减： --
    3. 位运算符
        * TODO： 首先你要对 十进制整数的二进制表示熟悉。 （以及十进制和二进制之间的相互转换要熟悉）
        * 位运算符可以对*由数字表示的二进制数据*进行更低层级的按位运算。（TODO：任何整数先转为二进制，再做按位运算， 这么理解对不？）
        * 按位与（`&`）： 对其整型操作数*逐位*执行布尔与（AND）操作。只有两个操作数中对应的位都是1,结果中的这一位才是1.
        * 按位或（`|`）： 对其整型操作数*逐位*执行布尔与（OR）操作。其中一个操作数相应的位为1,或两个操作数相应位都是1,那么结果中的这一位就为1.
        * 按位异或（`^`）： 对其整型操作数*逐位*执行布尔异或（XOR）操作。*异或*是指第一个操作数位true或第二个操作数位true，但两者不能同时为true。 ... TODO： 异或表示看不懂。
        * 操作非（`~`）： 属于一元运算符， 将操作数所有位取反。`~`运算符相当于改变它的符号并减1.（`~1`相当于`-1-1 (负一减一)`）。
        * DOTO：待补充。
* 4.9 关系表达式
    * 关系运算符用于测试两个值之间的关系（比如`相等 / 大于 / 小于 / 是xx的属性...`）
    1. 相等和不等运算符
        * `==` 和 `===` 运算符用于比较两个值是否相等。
        * `===` 也称为*恒等于*， 包括比较两个操作数的*类型*是否相等。
        * `!=`(不相等) 和 `!==`(*不严格相等*)
        * *JS对象的比较*是*引用的比较*，而不是值的比较。对象和其本身是相等的，但和其他任何对象都不相等。 （数组是特殊对象， 也是引用比较）
    2. 比较运算符
        * `< / > / <= / >=， 小于 大于 小于等于 大于等于`
        * 只有数字和字符串才能执行比较操作， 所以其他类型都将做类型转换
        * 字符串一次比较每个字符的 `Unicode字符编码顺序`。 
    3. `in`运算符
        * 左操作数是否是右操作数的属性名
    4. `instanceof`运算符
        * 左操作数是对象， 右操作数是对象的类， 判断一个对象是否是一个类的实例。
        * **所有对象都是`Object`的实例**。（这个判断是会包含对“父类”的检测）
* 4.10 逻辑表达式
    * 逻辑运算符`&& 、 || 、 !`是对操作数进行布尔算术运算。
    1. 逻辑与（`&&`）
        * **真值** 和 **假值**。 （不是true 或者 false， 但可以转为布尔值）
        * 两个操作数都为true运算结果才位true。
        * `&&`有时候*不一定返回布尔值*。
        ```
        var o = {x:2}
        var p = null;
        a = o && o.x; // 得到2 ：o是真值， 因此返回值 o.x。
        a = p && p.x; // 得到null： p是假值， 所以不回去计算 p.x。
        ```
        * `&&` 的行为有时候称为*短路*。
        ```
        if(a == b) stop(); 
        (a == b) stop(); //同上
        ```
    2. 逻辑或（`||`）
        * 常用在函数体内， 用来给参数提供默认值。
        ```
        function copy(o, p) {
            p = p || {}; // 如果参数p没有传入任何对象， 则使用 {}
            ...
        }
        ```
    3. 逻辑非（`!`）
        * `||`运算符是一元运算符。
        * 它的目的是将一个布尔值进行求反。
        * 和`&&`与`||`运算符不同， `!`运算符*首先*将其操作数转为布尔值， 然后再对布尔值求反。
* 4.11 赋值表达式
    * JS使用`=`运算符来给变量或者属性赋值。
    * 带操作的赋值： `+= / -= ...`。
* 4.12 表达式计算
    * JS可以*解释运行*由JS源代码组成的字符串， 并产生一个值。
    * JS通过全局函数 `eval()`来完成。
    * `eval()`是一个函数， 但由于它已经被当成运算符来对待了。
* 4.13 其他运算符
    1. 三元运算符： `? :`
    2. `typeof` 运算符：
        * 返回表示操作数类型的一个字符串。
        ```
        x               typeof
        undefined       "undefined"
        null            "object"
        true 或false     "boolean"
        任意数字或NaN      "number"
        任意数组           "object"   // 注意数组是被当作对象， 没有 "array"。
        任意函数           "function" // 而函数虽然是特殊对象， 但被特殊对待了。
        ...
        ```
        * 尽管函数是对象的一种，但是 typeof 还是将函数特殊对待。
    3. `delete`运算符：
        * 用来删除对象属性或者数组元素。
        * 删除不仅仅是设置一个undefined值，`in`检测时也将不存在。
        * 删除成功返回true，失败返回false（一些内置核心属性不能删除）。
    4. `void`运算符：
        * void是一元运算符， 操作数会照常计算，但忽略计算结果并返回undefined。
        * 最常用在客户端的URL -- `javascript:URL`, 让URL忽略表达式的计算结果。
        * `<a href="javascript:void window.open();">打开一个新窗口</a>`
    5. 逗号运算符`,`：
        * `,` 是二元运算符， 它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。

## 第5章 语句
    * JS的语句是以分号结束。
    * 例如赋值和函数调用这些右副作用的表达式可以单独作为语句。
    * JS解释器是依照语句顺序依次执行的， 同时JS提供了语句和控制结构来改变默认执行顺序： 条件语句， 循环语句， 跳转语句。5
* 5.1 表达式语句
    * JS中最简单的语句。
    * 赋值语句。
    * delete 运算符一般作为语句使用。
    * 函数调用是表达式语句的另一个大类。
* 5.2 复合语句和空语句
    * 多条语句联合在一起形成**复合语句**。
    * 只需用*花括号*将多条语句括起来即可。
    * 语句块结尾不需要分号， 块中的原始语句必须以分号结束;
    * 语句块中的每一行都有缩进，这不是必须的，但可以增强可读性和理解。
    * 空语句： 单独一个分号来表示一条空语句。
* 5.3 声明语句
    * `var` 和 `function` 都是声明语句。
    * 声明语句本身什么也不做，但它有一个重要意义，通过创建变量和函数，可以更好的组织代码语义。
    * 1. `var`
        * 声明一个或者多个变量：
        * 如果var语句出现在函数提内，那么它定义的是一个*局部变量*，其作用域就是这个函数;
        * 如果在顶层代码中使用var语句，它声明的是*全局变量*，在整个JS程序中都是可见的。
        * var声明的变量是无法通过delete删除的。（TODO： 待验证，在浏览器控制台测试不是这样的。）
        * var语句中的变量没有指定初始化表达式，那么变量的初始值位undefined。
        * `for循环`或者`for/in循环`组成部分的变量声明也会*变量提前*。
    * 2. `function`
        * 两种定义写法：
            * 将表达式赋值给一个变量： `var f = function(x) { return x; }`
            * 含有变量名的语句： `function f(x) { return f; }`
        * 定义时函数体内的语句并不执行， 花括号是必须的（循环语句或其他语句是可以省略花括号的）。
        * 函数声明通常出现在JS代码的最顶曾， 也可以嵌套在其他函数体内。（嵌套时函数声明只能出现在所在嵌套函数的顶部， 也就是不能在 if语句、 while循环或其他语句内声明函数）。
        * 函数声明语句创建的变量是无法删除。
* 5.4 条件语句
    * 通过判断*指定表达式的值*来决定执行还是跳过某些语句。
    1. `if`语句是一种基本的*控制语句*。 两种写法。
        `if / else` 语句通过判断一个表达式的计算结果来选择执行两条分支中的一条。
        ```
        if (expression) 
            statement
        ```
        ```
        if (expression) 
            statement1
        else 
            statement2
        ```
    2. `else if`
        * `else if`语句并不是真正的JS语句，只不过是多条`if/else`语句连在一起时的惯用写法。
        ```
        if () {
            //
        } else if {
            //
        } else if {
            //
        } else {
            //
        }
        ```
    3. `switch`
        * 当所有的分支都依赖于同一个表达式的值时， `else if`并不是最佳的解决方案， `switch`正好可以。
        * `case`只是指明要执行的代码起点， 但是没有指明终点。
        * `break`语句可以跳出switch语句或循环语句。
        * `default:`标签其实可以放在switch语句内的任何地方， *放在末尾是最合理和最常用的写法*。
        ```
        switch(n) {
            case 1:
                //
                break;
            case 2:
                //
                break;
            default:
                //
                break;
        }
        ```
* 5.5 循环
    * 为了理解条件语句，可以把JS中的代码想像成一条条分支路径。
    * **循环语句**就是程序路径的一个贿赂，可以让一部分代码重复执行。
    * JS中右4种循环语句： `while、 do/while、 for、 for/in`。
    1. `while`
        * 每次循环表达式的值也不同是很重要的一点， 否则可能造成死循环。
        ```
        while (expression)
            statement
        ```
    2. `do/while`
        * 和wihle相似，只不过是在循环的尾部检测循环表达式，意味着循环体*至少会执行一次*。
        ```
        do
            statement 
        while (expression);
        ```
    3. `for`
        * 比`while`更加方便的循环控制结构。
        * initizlize表达式*只在循环开始之前执行一次*。
        * test表达式的结果来决定是否执行循环体。
        * 如果test位真值， 则执行循环体内的语句， 最后执行increment表达式。
        * for循环中的那三个表达式中的任何一个都是可以忽略的，但是两个分号必不可少`for(;;)`。
        * 如果省略test表达式， 那么这将是一个*死循环*。
        ```
        for(initialize; test; increment)
            statement;
        ```
        * 等价于`while`如下写法
        ```
        initialize;
        while(test) {
            statement;
            increment;
        }
        ```
    4. `for/in`
        ```
        for (variable in object)
            statement;
        ```
        * for循环来**遍历数组元素**
        ```
        for(var i=0; i< a.length; i++)
            console.log(a[i]);
        ```
        * for/in循环则是方便**遍历对象属性**
        * 如果object表达式位null或者undefined，会跳过循环。
        ```
        for(var p in o) // 将*属性名*赋值给变量 p
            console.log(o[p]);
        ```
        * for/in循环数组枚举数组索引， JS数组不过是一种特殊对象
        * for/in循环并不会遍历对象的所有属性，只有*可枚举*的属性才会被遍历到。(很多语言核心定义的内置方法、属性都是*不可枚举*的)
        * 代码中定义的*所有*属性和方法都是可枚举的。
        * 属性枚举的顺序：
            * EAMCScripe规范并没有制定for/in循环按照何种顺序来枚举属性。
            * 主流浏览器都是选定义的属性先被枚举。
* 5.6 跳转
    0. 简介
        * break 语句是跳转到循环或者其他语句的结束。
        * continue 语句是终止本次循环的执行并开始下一次循环的执行。
        * 语句可以命名或带有标签， break和continue可以标识目标循环或者其他语句标签。
        * return 语句可以跳出函数体的执行，并提供本次调用的返回值。
        * throw 语句可以出发或者“抛出”一个异常，与try/catch/finally语句一起使用的，这些语句指定了处理异常的代码逻辑。（这个异常处理程序可以在同一个函数中或者更高层的调用栈中）
    1. 标签语句（很少用）
        * 语句是可以添加*标签*的，标签是由*语句前的标识符和冒号组成*。
        * `identifier: statement`
        * 通过给语句定义标签，就可以在程序的任何地方通过*标签名*引用这条语句。
        * 通过标签名可以在循环体内部使用break和continue来退出循环或者直接跳转到下一个循环的开始。
        * break和continue是唯一可以使用语句标签的语句。
        * 例子
        ```
        mainloop: while (token != null) {
            //
            continue mainloop;
            //
        }
        ```
    2. `break`语句
        * 单独使用break语句的作用是立即退出最内层的循环或switch语句。 `break;`
        * 同样允许break关键字后面跟随一个语句标签。
        * 无论break语句带不带标签，它的控制权都无法越过函数的边界。
    3. `continue`语句
        * continue语句和break语句非常类似，但它不是退出循环，而是转而执行下一次循环。
        * 不管continue语句带不带标签，它*只能在循环体内使用*。否则报语法错误。
    4. `return`语句
        * 函数中的return语句就是指定函数调用后的返回值。
        * return *只能在函数体内出现*。
        * return 没有带expression的话返回`undefined`。
    5. `throw`语句
        * 所谓异常是当发生了某种异常情况或错误时产生的一个信号。
        * 抛出异常，就是用信号通知发生了错误或异常状态。
        * 捕获异常，指的是处理这个信号，必须采取手段从异常中回复。
        * `try/catch/finally`语句可以捕捉异常。
        * `throw expression`;
        * 抛出异常的时候通常使用Error类型和其子类性：
        ```
        function factorial(x) {
            if (x < 0) throw new Error("x不能是附属");
            ...
        }
        ```
        * 抛出异常时JS解释器会立即停止当前正在执行的逻辑，并跳转至*就近*的异常处理程序。
        * 异常会沿着JS方法的此法结构和调用栈向上传播，如果没有找到任何异常处理程序，JS将会把异常当成程序错误来处理，并报告给用户。
    6. `try/catch/finally`语句
        * 处理异常机制的语句。
        * 当`try`块内某处发生了异常时，调用`catch`内的代码逻辑，不管是否产生异常`finally`块内的逻辑总是会执行。
        ```
        try {
            // 有时会抛出一个异常，要么是throw语句直接抛出异常， 要么是通过调用一个方法间接抛出异常
        } catch (e) {
             // 局部表量e获得对Error对象或者抛出的其他值的引用
        } finally {
            // 总会执行
        }
        * `catch / finally`是可选的，如果没有`catch从句`会先执行finally中的逻辑，然后向上传播这个异常，直到能找到处理这个异常的catch从句。
        * 如果finally从句抛出一个异常，这个异常将会代替正在抛出的异常。
        * 如果finally从句运行到了return语句，尽管已经抛出了异常且这个异常还没有出里，但是这个放那该法依然会正常返回。
* 5.7 其他语句类型
    0. 简介
        * JS剩下的三种语句： `width、 debugger、 use strict`
    1. `with`语句
        * `with`语句用于临时扩展作用域链。
        * 严格模式禁止使用with， 非严格模式不推荐。
        * 例子看不懂， 不做了解。
    2. `debugger`语句
        * 在运行的时候产生一个**断点**用于调试， 和浏览器上打断点是一样的。
        * 显然在浏览器上直接打断点更灵活，除非实在找不到要调试的代码行。
    3. `use strict`
        * `use strict`是`ECMAScript`引入的一条指令，指令不是语句（但非常接近语句）。
        * `"use strict"`仅仅是字符串， 需要加单引号或者爽引号。 
        * 只能出现在代码的开始或者函数体的开始。
        * TODO: 补充严格模式和非严格模式的区别。
* 5.8 JavaScript语句小结
    ```
    break           break [label]; // `[]`是可选的意思
    case            case expression;
    continue        continue [label];
    debugger        debugger;
    default         default; // switch 中标记默认的语句
    do/while        do statement while(expression);
    empty           ; // 什么都不做
    for             for(init; test;increment) statement;
    for/in          for(var in object)
    function        function name([param[], ...]) {body}
    label           label: statement
    return          return [expression];
    switch          switch(expression) {statements}
    throw           throw expression;
    try             try {statements} [catch {handler statements}] [finally {cheanup statements}]
    use strict      "use strict"
    var             var name=[=expr][,...];
    while           while(expression) statement
    with            with(object) stament
    ```


## 第6章 对象
* 6.0 简介
    * 对象是JS的基本类型，是复合值。 也可以看作是**属性的无序集合**，每个属性都是键/值队。
    * 属性名是字符串，因此可以把对象看成是字符串到值的映射。（类似数据结构有很多种叫法，比如`散列hash / 散列表hashtable/ 字典dictionary / 关联数组associative array`）
    * 对象还可以**从一个称为原型的对象继承属性**。
    * 对象的方法通常是继承属性。这种**原型继承**是JS的核心特真。
    * 除了字符串、对象、true、false、null和undefined之外，JS中的值都是对象。
    * 对象常见的用法是 创建create、 设置set、 查找query、 删除delete、检测test、枚举enumerate它的属性。
    * *属性*包括名字 和 值。
    * **属性的特性**
        * 可写，表示是否可以设置该属性的值。
        * 可枚举，表明是否可通过for/in循环返回该属性。
        * 可配置，表明是否可以删除或修改该属性。
    * **对象的特性**
        * *对象的原型*prototype指向另外一个对象，本对象的属性继承自它的原型对象。
        * *对象的类*class是一个标识对象类型的字符串。
        * *对象的扩展标记*extensible flag指明了（在ECMAScript5中）是否可以对该对象添加新属性。
    * 最后， 用下面这些属于来对*三类JS对象*和*两类属性*做区分
        * *内置对象*是由ECMAScript规范的对象或类。例如数组、函数、日期、正则。
        * *宿主对象*是由JS解释器所嵌入的宿主环境（浏览器、node的V8引擎）定义的。（客户端JS中表示网页结构的HTMLElement对象均是宿主对象）
        * *自定义对象*是由运行中JS代码创建的对象。
        * *自有属性*是直接在对象定义的属性。
        * *继承属性*是在对象的原型对象中定义的属性。
* 6.1 创建对象
    0. 创建方式： `对象直接量`、 `关键字new`和（ECMAScript5中的）`Object.create()`函数。
    1. 对象直接量： `var obj={o:1; y:2};`
    2. 通过new创建对象： 
        * 关键字new后跟随一个函数调用， 这里的函数称作**构造函数**。
        * 构造函数用以初始化一个新对象。
        * Js语言核心中的原始类型都包含内置构造函数。
        * 例如:`var o = new Object(); var a = new Array(); var d = new Date()`.
    3. 原型： 理解**原型链**
        * **每一个JS对象**（null除外）都和另一个对象相关联。“另一个”对象就是**原型**。
        * 所有通过*对象直接量*创建的对象由具有同一个原型对象，并可通过JS代码`Object.prototype`获得对原型对象的引用。
        * 通过关键字`new`和构造函数调用创建的对象的原型就是*构造函数的*`prototype`属性的值。
        * 因此使用`{}`创建对象和通过`new Object()`创建对象也继承自`Object.prototype`。
        * 同样通过`new Array()`创建的对象的原型就是`Array.prototype`,通过`new Date()`创建的对象的原型就是`Date.prototype`。
        * *没有原型的对象*不多，`Object.prototype`就是其中之一，它不继承任何属性。
        * 其他原型对象都是普通对象，普通对象都具有原型。
        * 所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自`Object.prototype`的原型。
        * 例如`Date.prototype`的属性继承自`Object.prototype`，因此`new Date()`创建的Date对象的属性**同时**继承自`Date.prototype`和`Object.prototype`。 这一系列链接的原型对象就是所谓的**原型链**。
    4. Object.create()
        * `Object.create()`方法创建新对象，其中第一个参数就是这个对象的**原型**，第二个可选参数，用以对对象的属性进行进一步描述。
        * `var o = Object.create({x:1, y:2}); // o继承了属性x和y`
        * 可以通过传入参数`null`来创建一个*没有原型*的新对象，但通过这种方式创建的对象不会继承任何东西，设置不包括基础方法，比他哦toString()，也就是说它将不能和`+`运算符一起正常工作。
        * `var o = Object.create(null); // o不继承任何属性和方法` 
        * 如果想创建一个普通的空对象（比如通过`{}`或`new Object()`创建的对象），需要传入`Object.prototype`:  `var o = Object.create(Object.prototype); // o 和 {} 或 new Object()一样`。
* 6.2 属性的查询和设置
    0. 简介
        * 可以通过点（.）或方括号（[]）运算符来获取属性的值。
        * 运算符左侧应当是一个表达式，它返回一个对象。
        * 对于点（.）来说，右侧必须是一个以属性名名称命名的简单标识符。
        * 对于方括号（[]）来说，方括号内必须是一个计算结果位字符串的表达式，这个字符串就是属性的名字，字符串。
    1. 作为关联数组的对象
        * `Object.xx`，点运算符和一个标识符，和C、Java中访问结构体或对象静态字段非常相似。
        * `Object.['xx']`，方括号和一个字符串，看起来更像数组，只是这个数组元素是通过*字符串索引*而不是数字索引。（这种数组就是我们所说的*关联数组*，也称做*散列、映射或字典*。）
        * JS对象都是关联数组。
    2. 继承
        * JS对象具有”自有属性“，也有一些属性是从原型对象继承而来的。
        * **查询对象o的属性x流程：**
            * 如果o中不存在x，将会继续在o的原型对象中查询属性x;
            * 如果原型对象中也没有x，但是这个原型对象也有原型，那么继续在 这个原型对象的原型 上继续执行查询， 直到找到x 或者 找到一个原型是null的对象位置。
            * 可以看到，对象的原型属性构成了一个**”链“**，通过这个链可以实现**属性的继承**。
        * **属性赋值流程：**
            * 首先检查原型链，判定是否允许赋值操作;
            * 如果o继承自一个只读属性，那么赋值操作是不被允许的;
            * 如果允许属性赋值操作，它也总是*在原始对象上*创建属性或者对已有属性的赋值，而不会去修改原型链;
            * *只有在查询属性才会体会到继承的存在，而设置属性和继承无关*，这是Js的重要特性，该特性让程序员可以有选择的覆盖继承属性。
            * 属性的赋值要么失败，要么创建一个属性，要么在原始对象中设置属性。担忧另一个例外！
            * **例外**： 
                *如果o继承自属性x，而这个属性是一个具有`setter`方法的`accessor`属性，那么这时调用`setter`方法而不是个o创建一个属性x。（类比php的魔术方法。）
                * setter方法是由对象o调用的，而不是定义这个属性的原型对象调用，因此如果setter方法定义任何属性，这个操作只是针对o本身，并不会修改原型链。
        3. 属性访问错误
            * 属性访问并不总是返回或这是一个值。
            * 查询一个不存在的属性并不会保存，返回找到的属性值或者返回undefined。
            * 但是如果这个对象不存在，那么就会报错。。。
            * 以下场景给对象o设置属性p会失败：
                * o中的属性p是只读的：不能给只读属性重新赋值（defineProperty()方法中有一个例外，可以对可配值的只读属性重新赋值）;
                * o中的属性p是继承属性，且它只是可读的：不能通过同名自有属性覆盖只读继承的属性。
                * o中不存在自有属性p：o没有使用setter方法继承属性p，*且*o的可扩展性是false。 如果o中不存在p，且没有setter方法可供调用，则p一定会添加值o中。 *但*如果o不是可扩展的，那么在o中不能定义新属性。
* 6.3 删除属性
    * `delete` 运算符可以删除对象的属性。
    * `delete` 只是断开属性和宿主对象的联系，而不回去操作属性中的属性。
    * `delete` *只能删除*自有属性，不能删除继承属性（要删除继承属性必须从这个属性的原型对象上删除它，而且这会影响到所有继承这个原型的对象）。
* 6.4 检测属性
    * 检测集合中成员的所属关系 -- 判断某个属性是否存在于某个对象中，可以使用`in`运算符、`hasPonPreperty()`和`propertyIsEnumerable()`方法来完成。
    * `in`运算符，如果对象的自有属性或继承属性包含着个属性则返回true。`"x" in obj`
    * 对象的`hasOwnProperty()`方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false。 `obj.hasOwnProperty("x")`。
    * `propertyIsEnumerable()`是`hasOwnProperty()`的增强版，只有检测到是自又属性且这个属性的可枚举性位true时它才返回true。
        * 某些内置属性是不可枚举的。
        * 通常由JS代码创建的属性都是可枚举的。
    * 除了使用in运算符之外，另一种方法是使用`!==`判断一个属性是否是undefined。（obj.x !== undefined, 除了属性被显式赋值位undefined。）
* 6.5 枚举属性
    * `for/in`循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性 和 继承属性，把属性名称赋值给循环变量。）
    * 对象*继承的内置方法是不可枚举的*。
    * 许多实用工具库给`Object.prototype`添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。
    * ECMAScript5定义两个用以枚举属性发的函数： `Object.keys()` 和 `Object.getOwnPropertyNames()`。
        * `Object.keys()`： 返回一个数组，这个数组由对象中*可枚举的*自有属性的名称组成。
        * `Object.getOwnPropertyNames()`： 返回对象所有自有属性的名称，而不仅仅是可枚举的属性。
* 6.6 属性getter和setter
    * 属性值可以用两个方法代替，这两个方法就是 `getter` 和 `setter`。
    * 当程序查询属性时， JS调用 `getter` 方法。
    * 当程序设置属性时， JS调用 `setter` 方法。
    ```
    var o = {
        a: 'init',
        data_prop: 'data_prop',
        get a() { // 方法名就是要访问的属性名， `get 空格 属性名()`
            console.log('getter a()');
        },
        set a(value) {
            console.log('setter a()');
        }
    };
    o.a;
    o.a = 1;
    ```
    * TODO: 如何控制所有属性的 get 和 set？
* 6.7 属性的特性
* 6.8 对象的三个属性
* 6.9 序列化对象
* 6.10 对象方法


## 第7章 数组
* 7.1 创建数组
* 7.2 数组元素的读和写
* 7.3 稀疏数组
* 7.4 数组长度
* 7.5 数组元素的添加和删除
* 7.6 数组遍历
* 7.7 多维数组
* 7.8 数组方法
* 7.9 ECMAScript 5中的数组方法
* 7.10 数组类型
* 7.11 类数组对象
* 7.12 作为数组的字符串


## 第8章 函数
* 8.1 函数定义
* 8.2 函数调用
* 8.3 函数的实参和形参
* 8.4 作为值的函数
* 8.5 作为命名空间的函数
* 8.6 闭包
* 8.7 函数属性、方法和构造函数
* 8.8 函数式编程


## 第9章 类和模块
* 9.1 类和原型
* 9.2 类和构造函数
* 9.3 JavaScript中Java式的类继承
* 9.4 类的扩充
* 9.5 类和类型
* 9.6 JavaScript中的面向对象技术
* 9.7 子类
* 9.8 ECMAScript 5 中的类
* 9.9 模块


## 第10章 正则表达式的模式匹配
* 10.1 正则表达式的定义
* 10.2 用于模式匹配的String方法
* 10.3 RegExp对象


## 第11章 JavaScript的子集和扩展
* 11.1 JavaScript的子集
* 11.2 常量和局部变量
* 11.3 解构赋值
* 11.4 迭代
* 11.5 函数简写
* 11.6 多catch 从句
* 11.7 E4X: ECMAScript for XML


## 第12章 服务器端JavaScript
* 12.1 用Rhino脚本化Java
* 12.2 用Node实现异步I/O
