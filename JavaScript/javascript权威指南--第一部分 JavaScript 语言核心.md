## 第一部分 JavaScript 语言核心

## 第2章 词法结构
* 2.0 简介
    * **词法结构**是一套基础性规则， 用来描述如何使用这门语言来编写程序。
* 2.1 字符集
    * `JavaScript` 程序使用`Unicode` 字符集编写的。
    * 区分大小写（另注：HTML 不区分大小写， XHTML 区分大小写）。
    * 空格、 换行符 和 格式控制符： 
        * 空格--`'\u0020'`, 水平制表符`'\u0009'` ... 等。
        * 回车符加换行符一起被解析为一个**单行结束符**。 
    * `Unicode` 转移序列， 因为有的软硬件不能显示或输入 `Unicode` 字符全集： `'caf\u00e9'` == `'café'`
* 2.2 注释
    * 单行注释： `//`。
    * 多行注释： `/* ... */`。
* 2.3 直接量
    * 程序中**直接使用的数据值**就叫做直接量。
* 2.4 标识符和保留字
    * **标识符** 就是一个名字。
    * 标识符**必须**以字母、 下划线、 美元符 开始。
    * **保留字**： `JavaScript` 的关键字， 不能被用做标识符。
* 2.5 可选的分号
    * **分号**分割语句不是必须的， 除非影响代码的可读性和简洁性。


## 第3章 类型、值和变量
* **3.0 简介**
    * 能够表示并操作的值的类型称作**数据类型**
    * 数据类型分为两类： 
        * **原始类型**： 数字、 字符串 和 布尔值。（**特殊原始值**: `null 空` 和 `undefined 未定义`）。
        * **对象类型**： 每个属性都由 *键/值对* 构成。 （**特殊对象**： 全局对象、数组、函数）。
    * 函数： 是特殊对象。 
        * 被 `new` 运算符建立对象的函数称为**构造函数**。
        * 每个**构造函数**定义了一**类**对象--由构造函数初始化的对象组成的集合。
        * 除了`Array类` 和 `Function类`意外， JS 语言核心海定义了其他三种游有用的类： `Date / RegExp / Error`。 （简单点讲， 就是可以被 `new` 成对象的类型。）
    * 数据类型同样可分为 *可变类型 mutable* 和 *不可变类型 immutable*： 对象是可变类型
    * **词法作用域**： 
        * 不在任何*函数内*声明的变量称作**全局变量**, 它在 JS 程序中的任何地方都是可见的。
        * 在*函数内*声明的变量具有**函数作用域**。
* 3.1 数字
    * `JavaScript` **不区分**整数值和浮点数值。
    * 十六进制： `0x`或 `0X` 为前缀。
    * 八进制： `0` 为前缀。
    * `Math`对象。
    * `Date()`构造函数。
* 3.2 文本
    * **字符串**是一组由16位值组成的不可变的**有序序列**， 每个字符串通常来自于 `Unicode` 字符集。
    * 转义字符： 反斜杠`\`后面加一个字符。（`\t`: 水平制符; `\n`: 换行符 ...）
    * 字符串的方法： `s.chatAt; s.substring; s.slice; s.indexOf ...`
    * 模式匹配： `RegExp()`构造函数来创建表示文本匹配模式的对象。
        * 这些模式称为**正则表达式**。
        * JS 采用`Perl`中的正则表达式语法。
* 3.3 布尔值
    * 只有两个值： `true` 和 `false`。
    * JS 的任何值都可以被转为布尔。
    * `undefined、 null、 0、 -0、 NaN、 ""` 都会被转成 `false`。
* 3.4 null和undefined
    * `typeof null` 返回字符串 "object"， 也就是说 `null`是特殊的对象值。
* 3.5 **全局对象**
    * JS解释器启动的时候就创建。
    * 全局属性： `undefined Infinity NaN ...` 
    * 全局函数： `isNaN() parseInt() eval() ...`
    * 构造函数： `Date() RegExp() String() Object() Array()`
    * 全局对象： `Math JSON`
    * `Window`对象充当了**全局对象**
* 3.6 包装对象
    * `var s="hello"; s.substring(xxx)`; 字符串既然不是对象， 为什么会有属性？
    * 答： 只要引用了字符串s的属性，JS就会将字符串值通过调用`new String(s)`的方式转为对象。
    * 存取字符串、 数字或布尔值的属性*时临时创建的对象*称做**包装对象**。（偶尔用来区分 *字符串和字符串对象*、 *数字和数值对象*、 *布尔值和布尔对象*）
    * `String() 、Number()、 Boolean()`构造函数可以用来显示创建**包装对象**。
* 3.7 不可变的原始值和可变的对象引用
    * 对象都是**引用类型**
    * 对象值都是**引用**
    * 对象或数组赋值给一个变量，仅仅是赋值引用值，对象本身没有复制一次。（需要**深度拷贝**）
    * 对象或数组做比较，必须比较他们的每个属性。（深度比较）
* 3.8 类型转换
    * `==` 和 `===` 的区别。（推荐使用 `===` 做比较）
    * 显示类型转换： 使用函数`Boolean()、 Number()、 String()、 Object()`。
        * 除了`null` 和 `undefined` 之外任何值都由`toString()`方法， 通常与`String()` 函数的结果一致。（转为字符串类型）
    * 对象转原始值： 
        * 所有的对象继承了两个转换方法： `toString()` 和 `valueOf()`
        * `toString()`： 对象到字符串。
        * `valueOf()`： 对象到数字。
        * 对象到字符串转换步骤： 优先 `toString()`, 没有则调用 `valueOf()`,不然就异常。
        * 对象到数字转换步骤： 优先 `valueOf()`, 没有则调用 `toString()`,不然就异常。
* 3.9 变量声明
    * 使用关键字 `var` 来声明。
    * 变量没有制定初始值， 它的初始值就是 `undefined`。
* 3.10 变量作用域
    * *全局作用域* 和 *局部作用域*（函数作用域）
    * 局部作用域**优先级**高于全局作用域
    * 声明全局变量*可以不用* `var`。（**但**不代表不用`var`声明的都是全局变量）
    * JS没有*块级作用域*，而是使用**函数作用域**。
    * JS 会自动**声明提前** -- 变量在声明之前可以使用， JS函数里声明的所有变量（但不包括赋值）都会被”提前“至函数提的顶部。
    ```javascript
    var scope = "global";
    function f() {
        console.log(scope); // undefined 而非 global
        var scope = "local"; // 赋值
        console.log(scope); // local
    }

    变量提前 -- 等价于如下
    function f() {
        var scope; // 函数顶部声明了局部变量
        console.log(scope); // undefined 而非 global
        scope = "local"; // 初始化赋值
        console.log(scope); // local
    }
    ```
    * 所以先声明后使用是一个好习惯
    * **作用域链**
        * **全局变量**在程序中*始终*是有定义的.
        * **局部变量**在声明它的函数体内*以及其所嵌套的函数内*始终是有定义的.
        * 作用域链
            * 把*局部变量*看做是自定义实现的对象属性:
                * 每一段JS代码(全局代码或函数)都有一个与之关联的**作用域链**.
                * 这个作用域链是一个对象列表或者链表, 这组对象定义了这段代码"作用域中"的变量.
                * 当JS查找变量x的值的时候(此过程乘坐"变量解析"), 它会从链中的第一个对象开始查找, 有x则使用, 无责继续查找链上的下一个对象, 以此类推.
                * 如果作用域链上没有任何一个对象属性x, 抛出引用错误异常.
            * 在JS最顶层代码中(不包含在任何函数定义内的代码), *作用域链*由一个全局对象组成:
                * 在不包含嵌套的函数体内, *作用域链*上有两个对象: 第一个是定义函数参数和局部变量的对象, 第二个是全局对象;
                * 在一个嵌套的函数体内, *作用域链*上至少有三个对象: 
                    * 当定义一个函数时, 它实际上保存一个*作用域链*; 
                    * 当调用这个函数式, 它创建一个新的对象来存储它的局部变量, 并将这个对象添加至保存的那个*作用域链*上, 同时创建一个新的更长的表示函数调用作用域的"链".
                    * 对于**嵌套函数**来讲, 每次调用外部函数时, 内部函数又会重新定义一遍. 因为每次调用外部函数的时候, 作用域链都是不同的.
                    * **总之, 嵌套函数的作用域链是最难理解同时也是最重要的! 有助于理解闭包! TODO:看不懂嵌套函数的作用域链.**



## 第4章 表达式和运算符
* 4.0 简介
    * **表达式**是JS中的一个*短语*, JS解释器会将其计算成一个结果。
    * 将*简单表达式*组成*复杂表达式*最常用的方法就是使用**运算符**。
* 4.1 原始表达式
    * **原始表达式**是*表达式*的最小单位--它们不再包含其他表达式。
    * JS中的原始表达式包含*常量、直接量、关键字、变量*。（不过好像很少直接使用原始表达式）
    * 例子：
    ```
    1.23 // 直接量
    true // 关键字
    i    // 变量
    ```
* 4.2 对象和数组的初始化表达式
    * 对象和数组初始化表达式实际上是一个*新创建的对象和数组*。
    * ”对象直接量“和”数组直接量“*不是原始表达式*， 因为它们所包含的成员或元素都是*子表达式*。
    * 数组初始化表达式是通过一对方括号和其内的逗号隔开的列表构成的， 初始化结果就是一个新创建的数组。 （`[]; [1+2, 3+4]`）
    * 数组表达式可以嵌套。（多维数组 `[[1, 2], [3, 4]]`）
    * JS对数组初始化表达式进行求值的时候， 数组初始化表达式中的-元素表达式-也会各自计算一次。
    *  数组直接量中的都要之间的元素可以省略，*省略的空位会填充undefined*。(`[1,,,3]`相当于`[1, undefined, undefined, 3]`)
    * 对象表达式也可以嵌套， 在初始化时也会各自计算。（`{o: {x:1, y:2}}`）
* 4.3 函数定义表达式
    * 函数定义表达式定义一个JS函数， *表达式的值*是这个新定义的函数。
* 4.4 属性访问表达式
    * 属性访问表达式可得到一个对象属性或一个数组元素的值。
    * JS为属性访问定义两种方法： 访问的属性不存在则值为 `undefined`。
    ```
    expression.identifier
    expression[identifier]
    ```
* 4.5 调用表达式
    * 调用表达式是一种调用（或执行）函数或方法的语法表示。
    * 函数名+括号。
* 4.6 对象创建表达式
    * 对象创建表达式创建一个对象*并*调用一个函数(**构造函数**)初始化新对象的属性.
    ```
    new Object();
    new Point(2, 3);
    ```
    * 如果对象创建表达式不需要传入参数给构造函数的话, 空括号可以省略.
    ```
    new Object;
    new Point;
    ```
* 4.7 运算符概述
    * 运算符用于算数表达式 / 比较表达式等等.
    * 大多数运算符都是由*标点符号*表示, 例如 `+` / `-` / `-`.
    * 一些运算符则是由*关键字*表示, 例如 `delete` 和 `instanceof`.
    * 运算符的优先级: TODO: 补充个截图比较直观.
    1. 操作数的个数:
        * 一元运算符: `-x` (求负数)
        * 二元运算符: `x+y`
        * 三元运算符: `?:`
    2. 操作数类型和结果类型:
        * 一般由运算符决定结果: 例如 `'3' * '5'` 得到 15(整型) , 而 `'3' + '5'` 得到 35(字符串).
    3. 左值:
        * 指的是"表达式只能出现在赋值运算符的*左侧*". `a = 1;`
        * JS中变量 / 对象属性 和 数组元素均是左值. 
    4. 运算符的副作用:
        * `++ / --` 此类运算符包含隐式赋值, 使得使用这个变量的表达式都会受影响.
        * `delete` 运算符也有副作用, 删除对象属性后访问得到是`undefined`, 影响到了对应相关的使用.
    5. 运算符优先级:
        * `typeof`是优先级*最高*的运算符之一.
        * 不确定优先级的话, 可以使用括号来强制指定运算次序. (表示一直这样!)
    6. 运算符的结合性:
    7. 运算顺序:
        * Js总是从**左到右顺序**来计算表达式的.
        * 只有在任何一个表达式具有副作用而影响到其他表达式的时候, 其求职顺序才会看上去有所不同.
* 4.8 算术表达式
    * 基本算数运算符是`+ - * / % 加减乘除余`。
    * 无法转为数字的操作数都转换为`NaN`值。（除了加法会被转为字符串拼接）
    * 除数为0的运算结果为正无穷大或负无穷大。 `0/0`的结果是`NaN`。
    1. "+"运算符
        * 二元加法运算符可以对两个数字做**加法**， 也可以做**字符串连接**操作。
        * *优先*考虑字符串连接，其中一个操作数是字符串，另一个操作数也将会转为字符串。
        * 如果一个*操作数是对象*，则会遵循对象到*原始值*的转换规则转换为*原始类值*： 日期对象通过`toString()`方法转换， 其他对象通过`valueOf()`方法转换（如果它返回一个原始值的话）。
        * 由于多数对象都不具备可用的`valueOf()`方法，因此它们会通过`toString()`方法来执行抓换。 `1 + {}` 得到 `"1[object Object]"`
    2. 一元算术运算符
        * 一元加法： +
        * 一元减法： -
        * 递增： ++ （运算符在操作数之前称为*前增量运算符*，在操作数之后称为*后增量运算符*）
        * 递减： --
    3. 位运算符
        * TODO： 首先你要对 十进制整数的二进制表示熟悉。 （以及十进制和二进制之间的相互转换要熟悉）
        * 位运算符可以对*由数字表示的二进制数据*进行更低层级的按位运算。（TODO：任何整数先转为二进制，再做按位运算， 这么理解对不？）
        * 按位与（`&`）： 对其整型操作数*逐位*执行布尔与（AND）操作。只有两个操作数中对应的位都是1,结果中的这一位才是1.
        * 按位或（`|`）： 对其整型操作数*逐位*执行布尔与（OR）操作。其中一个操作数相应的位为1,或两个操作数相应位都是1,那么结果中的这一位就为1.
        * 按位异或（`^`）： 对其整型操作数*逐位*执行布尔异或（XOR）操作。*异或*是指第一个操作数位true或第二个操作数位true，但两者不能同时为true。 ... TODO： 异或表示看不懂。
        * 操作非（`~`）： 属于一元运算符， 将操作数所有位取反。`~`运算符相当于改变它的符号并减1.（`~1`相当于`-1-1 (负一减一)`）。
        * DOTO：待补充。
* 4.9 关系表达式
    * 关系运算符用于测试两个值之间的关系（比如`相等 / 大于 / 小于 / 是xx的属性...`）
    1. 相等和不等运算符
        * `==` 和 `===` 运算符用于比较两个值是否相等。
        * `===` 也称为*恒等于*， 包括比较两个操作数的*类型*是否相等。
        * `!=`(不相等) 和 `!==`(*不严格相等*)
        * *JS对象的比较*是*引用的比较*，而不是值的比较。对象和其本身是相等的，但和其他任何对象都不相等。 （数组是特殊对象， 也是引用比较）
    2. 比较运算符
        * `< / > / <= / >=， 小于 大于 小于等于 大于等于`
        * 只有数字和字符串才能执行比较操作， 所以其他类型都将做类型转换
        * 字符串一次比较每个字符的 `Unicode字符编码顺序`。 
    3. `in`运算符
        * 左操作数是否是右操作数的属性名
    4. `instanceof`运算符
        * 左操作数是对象， 右操作数是对象的类， 判断一个对象是否是一个类的实例。
        * **所有对象都是`Object`的实例**。（这个判断是会包含对“父类”的检测）
* 4.10 逻辑表达式
* 4.11 赋值表达式
* 4.12 表达式计算
* 4.13 其他运算符


## 第5章 语句
* 5.1 表达式语句
* 5.2 复合语句和空语句
* 5.3 声明语句
* 5.4 条件语句
* 5.5 循环
* 5.6 跳转
* 5.7 其他语句类型
* 5.8 JavaScript语句小结


## 第6章 对象
* 6.1 创建对象
* 6.2 属性的查询和设置
* 6.3 删除属性
* 6.4 检测属性
* 6.5 枚举属性
* 6.6 属性getter和setter
* 6.7 属性的特性
* 6.8 对象的三个属性
* 6.9 序列化对象
* 6.10 对象方法


## 第7章 数组
* 7.1 创建数组
* 7.2 数组元素的读和写
* 7.3 稀疏数组
* 7.4 数组长度
* 7.5 数组元素的添加和删除
* 7.6 数组遍历
* 7.7 多维数组
* 7.8 数组方法
* 7.9 ECMAScript 5中的数组方法
* 7.10 数组类型
* 7.11 类数组对象
* 7.12 作为数组的字符串


## 第8章 函数
* 8.1 函数定义
* 8.2 函数调用
* 8.3 函数的实参和形参
* 8.4 作为值的函数
* 8.5 作为命名空间的函数
* 8.6 闭包
* 8.7 函数属性、方法和构造函数
* 8.8 函数式编程


## 第9章 类和模块
* 9.1 类和原型
* 9.2 类和构造函数
* 9.3 JavaScript中Java式的类继承
* 9.4 类的扩充
* 9.5 类和类型
* 9.6 JavaScript中的面向对象技术
* 9.7 子类
* 9.8 ECMAScript 5 中的类
* 9.9 模块


## 第10章 正则表达式的模式匹配
* 10.1 正则表达式的定义
* 10.2 用于模式匹配的String方法
* 10.3 RegExp对象


## 第11章 JavaScript的子集和扩展
* 11.1 JavaScript的子集
* 11.2 常量和局部变量
* 11.3 解构赋值
* 11.4 迭代
* 11.5 函数简写
* 11.6 多catch 从句
* 11.7 E4X: ECMAScript for XML


## 第12章 服务器端JavaScript
* 12.1 用Rhino脚本化Java
* 12.2 用Node实现异步I/O
