## 第一部分 JavaScript 语言核心

## 第2章 词法结构
* 2.0 简介
    * **词法结构**是一套基础性规则， 用来描述如何使用这门语言来编写程序。
* 2.1 字符集
    * `JavaScript` 程序使用`Unicode` 字符集编写的。
    * 区分大小写（另注：HTML 不区分大小写， XHTML 区分大小写）。
    * 空格、 换行符 和 格式控制符： 
        * 空格--`'\u0020'`, 水平制表符`'\u0009'` ... 等。
        * 回车符加换行符一起被解析为一个**单行结束符**。 
    * `Unicode` 转移序列， 因为有的软硬件不能显示或输入 `Unicode` 字符全集： `'caf\u00e9'` == `'café'`
* 2.2 注释
    * 单行注释： `//`。
    * 多行注释： `/* ... */`。
* 2.3 直接量
    * 程序中**直接使用的数据值**就叫做直接量。
* 2.4 标识符和保留字
    * **标识符** 就是一个名字。
    * 标识符**必须**以字母、 下划线、 美元符 开始。
    * **保留字**： `JavaScript` 的关键字， 不能被用做标识符。
* 2.5 可选的分号
    * **分号**分割语句不是必须的， 除非影响代码的可读性和简洁性。


## 第3章 类型、值和变量
* **3.0 简介**
    * 能够表示并操作的值的类型称作**数据类型**
    * 数据类型分为两类： 
        * **原始类型**： 数字、 字符串 和 布尔值。（**特殊原始值**: `null 空` 和 `undefined 未定义`）。
        * **对象类型**： 每个属性都由 *键/值对* 构成。 （**特殊对象**： 全局对象、数组、函数）。
    * 函数： 是特殊对象。 
        * 被 `new` 运算符建立对象的函数称为**构造函数**。
        * 每个**构造函数**定义了一**类**对象--由构造函数初始化的对象组成的集合。
        * 除了`Array类` 和 `Function类`意外， JS 语言核心海定义了其他三种游有用的类： `Date / RegExp / Error`。 （简单点讲， 就是可以被 `new` 成对象的类型。）
    * 数据类型同样可分为 *可变类型 mutable* 和 *不可变类型 immutable*： 对象是可变类型
    * **词法作用域**： 
        * 不在任何*函数内*声明的变量称作**全局变量**, 它在 JS 程序中的任何地方都是可见的。
        * 在*函数内*声明的变量具有**函数作用域**。
* 3.1 数字
    * `JavaScript` **不区分**整数值和浮点数值。
    * 十六进制： `0x`或 `0X` 为前缀。
    * 八进制： `0` 为前缀。
    * `Math`对象。
    * `Date()`构造函数。
* 3.2 文本
    * **字符串**是一组由16位值组成的不可变的**有序序列**， 每个字符串通常来自于 `Unicode` 字符集。
    * 转义字符： 反斜杠`\`后面加一个字符。（`\t`: 水平制符; `\n`: 换行符 ...）
    * 字符串的方法： `s.chatAt; s.substring; s.slice; s.indexOf ...`
    * 模式匹配： `RegExp()`构造函数来创建表示文本匹配模式的对象。
        * 这些模式称为**正则表达式**。
        * JS 采用`Perl`中的正则表达式语法。
* 3.3 布尔值
    * 只有两个值： `true` 和 `false`。
    * JS 的任何值都可以被转为布尔。
    * `undefined、 null、 0、 -0、 NaN、 ""` 都会被转成 `false`。
* 3.4 null和undefined
    * `typeof null` 返回字符串 "object"， 也就是说 `null`是特殊的对象值。
* 3.5 **全局对象**
    * JS解释器启动的时候就创建。
    * 全局属性： `undefined Infinity NaN ...` 
    * 全局函数： `isNaN() parseInt() eval() ...`
    * 构造函数： `Date() RegExp() String() Object() Array()`
    * 全局对象： `Math JSON`
    * `Window`对象充当了**全局对象**
* 3.6 包装对象
    * `var s="hello"; s.substring(xxx)`; 字符串既然不是对象， 为什么会有属性？
    * 答： 只要引用了字符串s的属性，JS就会将字符串值通过调用`new String(s)`的方式转为对象。
    * 存取字符串、 数字或布尔值的属性*时临时创建的对象*称做**包装对象**。（偶尔用来区分 *字符串和字符串对象*、 *数字和数值对象*、 *布尔值和布尔对象*）
    * `String() 、Number()、 Boolean()`构造函数可以用来显示创建**包装对象**。
* 3.7 不可变的原始值和可变的对象引用
    * 对象都是**引用类型**
    * 对象值都是**引用**
    * 对象或数组赋值给一个变量，仅仅是赋值引用值，对象本身没有复制一次。（需要**深度拷贝**）
    * 对象或数组做比较，必须比较他们的每个属性。（深度比较）
* 3.8 类型转换
    * `==` 和 `===` 的区别。（推荐使用 `===` 做比较）
    * 显示类型转换： 使用函数`Boolean()、 Number()、 String()、 Object()`。
        * 除了`null` 和 `undefined` 之外任何值都由`toString()`方法， 通常与`String()` 函数的结果一致。（转为字符串类型）
    * 对象转原始值： 
        * 所有的对象继承了两个转换方法： `toString()` 和 `valueOf()`
        * `toString()`： 对象到字符串。
        * `valueOf()`： 对象到数字。
        * 对象到字符串转换步骤： 优先 `toString()`, 没有则调用 `valueOf()`,不然就异常。
        * 对象到数字转换步骤： 优先 `valueOf()`, 没有则调用 `toString()`,不然就异常。
* 3.9 变量声明
    * 使用关键字 `var` 来声明。
    * 变量没有制定初始值， 它的初始值就是 `undefined`。
* 3.10 变量作用域
    * *全局作用域* 和 *局部作用域*（函数作用域）
    * 局部作用域**优先级**高于全局作用域
    * 声明全局变量*可以不用* `var`。（**但**不代表不用`var`声明的都是全局变量）
    * JS没有*块级作用域*，而是使用**函数作用域**。
    * JS 会自动**声明提前** -- 变量在声明之前可以使用， JS函数里声明的所有变量（但不包括赋值）都会被”提前“至函数提的顶部。
    ```javascript
    var scope = "global";
    function f() {
        console.log(scope); // undefined 而非 global
        var scope = "local"; // 赋值
        console.log(scope); // local
    }

    变量提前 -- 等价于如下
    function f() {
        var scope; // 函数顶部声明了局部变量
        console.log(scope); // undefined 而非 global
        scope = "local"; // 初始化赋值
        console.log(scope); // local
    }
    ```
    * 所以先声明后使用是一个好习惯
    * **作用域链**
        * **全局变量**在程序中*始终*是有定义的.
        * **局部变量**在声明它的函数体内*以及其所嵌套的函数内*始终是有定义的.
        * 作用域链
            * 把*局部变量*看做是自定义实现的对象属性:
                * 每一段JS代码(全局代码或函数)都有一个与之关联的**作用域链**.
                * 这个作用域链是一个对象列表或者链表, 这组对象定义了这段代码"作用域中"的变量.
                * 当JS查找变量x的值的时候(此过程乘坐"变量解析"), 它会从链中的第一个对象开始查找, 有x则使用, 无责继续查找链上的下一个对象, 以此类推.
                * 如果作用域链上没有任何一个对象属性x, 抛出引用错误异常.
            * 在JS最顶层代码中(不包含在任何函数定义内的代码), *作用域链*由一个全局对象组成:
                * 在不包含嵌套的函数体内, *作用域链*上有两个对象: 第一个是定义函数参数和局部变量的对象, 第二个是全局对象;
                * 在一个嵌套的函数体内, *作用域链*上至少有三个对象: 
                    * 当定义一个函数时, 它实际上保存一个*作用域链*; 
                    * 当调用这个函数式, 它创建一个新的对象来存储它的局部变量, 并将这个对象添加至保存的那个*作用域链*上, 同时创建一个新的更长的表示函数调用作用域的"链".
                    * 对于**嵌套函数**来讲, 每次调用外部函数时, 内部函数又会重新定义一遍. 因为每次调用外部函数的时候, 作用域链都是不同的.
                    * **总之, 嵌套函数的作用域链是最难理解同时也是最重要的! 有助于理解闭包! TODO:看不懂嵌套函数的作用域链.**



## 第4章 表达式和运算符
* 4.0 简介
    * **表达式**是JS中的一个*短语*, JS解释器会将其计算成一个结果。
    * 将*简单表达式*组成*复杂表达式*最常用的方法就是使用**运算符**。
* 4.1 原始表达式
    * **原始表达式**是*表达式*的最小单位--它们不再包含其他表达式。
    * JS中的原始表达式包含*常量、直接量、关键字、变量*。（不过好像很少直接使用原始表达式）
    * 例子：
    ```
    1.23 // 直接量
    true // 关键字
    i    // 变量
    ```
* 4.2 对象和数组的初始化表达式
    * 对象和数组初始化表达式实际上是一个*新创建的对象和数组*。
    * ”对象直接量“和”数组直接量“*不是原始表达式*， 因为它们所包含的成员或元素都是*子表达式*。
    * 数组初始化表达式是通过一对方括号和其内的逗号隔开的列表构成的， 初始化结果就是一个新创建的数组。 （`[]; [1+2, 3+4]`）
    * 数组表达式可以嵌套。（多维数组 `[[1, 2], [3, 4]]`）
    * JS对数组初始化表达式进行求值的时候， 数组初始化表达式中的-元素表达式-也会各自计算一次。
    *  数组直接量中的都要之间的元素可以省略，*省略的空位会填充undefined*。(`[1,,,3]`相当于`[1, undefined, undefined, 3]`)
    * 对象表达式也可以嵌套， 在初始化时也会各自计算。（`{o: {x:1, y:2}}`）
* 4.3 函数定义表达式
    * 函数定义表达式定义一个JS函数， *表达式的值*是这个新定义的函数。
* 4.4 属性访问表达式
    * 属性访问表达式可得到一个对象属性或一个数组元素的值。
    * JS为属性访问定义两种方法： 访问的属性不存在则值为 `undefined`。
    ```
    expression.identifier
    expression[identifier]
    ```
* 4.5 调用表达式
    * 调用表达式是一种调用（或执行）函数或方法的语法表示。
    * 函数名+括号。
* 4.6 对象创建表达式
    * 对象创建表达式创建一个对象*并*调用一个函数(**构造函数**)初始化新对象的属性.
    ```
    new Object();
    new Point(2, 3);
    ```
    * 如果对象创建表达式不需要传入参数给构造函数的话, 空括号可以省略.
    ```
    new Object;
    new Point;
    ```
* 4.7 运算符概述
    * 运算符用于算数表达式 / 比较表达式等等.
    * 大多数运算符都是由*标点符号*表示, 例如 `+` / `-` / `-`.
    * 一些运算符则是由*关键字*表示, 例如 `delete` 和 `instanceof`.
    * 运算符的优先级: TODO: 补充个截图比较直观.
    1. 操作数的个数:
        * 一元运算符: `-x` (求负数)
        * 二元运算符: `x+y`
        * 三元运算符: `?:`
    2. 操作数类型和结果类型:
        * 一般由运算符决定结果: 例如 `'3' * '5'` 得到 15(整型) , 而 `'3' + '5'` 得到 35(字符串).
    3. 左值:
        * 指的是"表达式只能出现在赋值运算符的*左侧*". `a = 1;`
        * JS中变量 / 对象属性 和 数组元素均是左值. 
    4. 运算符的副作用:
        * `++ / --` 此类运算符包含隐式赋值, 使得使用这个变量的表达式都会受影响.
        * `delete` 运算符也有副作用, 删除对象属性后访问得到是`undefined`, 影响到了对应相关的使用.
    5. 运算符优先级:
        * `typeof`是优先级*最高*的运算符之一.
        * 不确定优先级的话, 可以使用括号来强制指定运算次序. (表示一直这样!)
    6. 运算符的结合性:
    7. 运算顺序:
        * Js总是从**左到右顺序**来计算表达式的.
        * 只有在任何一个表达式具有副作用而影响到其他表达式的时候, 其求职顺序才会看上去有所不同.
* 4.8 算术表达式
    * 基本算数运算符是`+ - * / % 加减乘除余`。
    * 无法转为数字的操作数都转换为`NaN`值。（除了加法会被转为字符串拼接）
    * 除数为0的运算结果为正无穷大或负无穷大。 `0/0`的结果是`NaN`。
    1. "+"运算符
        * 二元加法运算符可以对两个数字做**加法**， 也可以做**字符串连接**操作。
        * *优先*考虑字符串连接，其中一个操作数是字符串，另一个操作数也将会转为字符串。
        * 如果一个*操作数是对象*，则会遵循对象到*原始值*的转换规则转换为*原始类值*： 日期对象通过`toString()`方法转换， 其他对象通过`valueOf()`方法转换（如果它返回一个原始值的话）。
        * 由于多数对象都不具备可用的`valueOf()`方法，因此它们会通过`toString()`方法来执行抓换。 `1 + {}` 得到 `"1[object Object]"`
    2. 一元算术运算符
        * 一元加法： +
        * 一元减法： -
        * 递增： ++ （运算符在操作数之前称为*前增量运算符*，在操作数之后称为*后增量运算符*）
        * 递减： --
    3. 位运算符
        * TODO： 首先你要对 十进制整数的二进制表示熟悉。 （以及十进制和二进制之间的相互转换要熟悉）
        * 位运算符可以对*由数字表示的二进制数据*进行更低层级的按位运算。（TODO：任何整数先转为二进制，再做按位运算， 这么理解对不？）
        * 按位与（`&`）： 对其整型操作数*逐位*执行布尔与（AND）操作。只有两个操作数中对应的位都是1,结果中的这一位才是1.
        * 按位或（`|`）： 对其整型操作数*逐位*执行布尔与（OR）操作。其中一个操作数相应的位为1,或两个操作数相应位都是1,那么结果中的这一位就为1.
        * 按位异或（`^`）： 对其整型操作数*逐位*执行布尔异或（XOR）操作。*异或*是指第一个操作数位true或第二个操作数位true，但两者不能同时为true。 ... TODO： 异或表示看不懂。
        * 操作非（`~`）： 属于一元运算符， 将操作数所有位取反。`~`运算符相当于改变它的符号并减1.（`~1`相当于`-1-1 (负一减一)`）。
        * DOTO：待补充。
* 4.9 关系表达式
    * 关系运算符用于测试两个值之间的关系（比如`相等 / 大于 / 小于 / 是xx的属性...`）
    1. 相等和不等运算符
        * `==` 和 `===` 运算符用于比较两个值是否相等。
        * `===` 也称为*恒等于*， 包括比较两个操作数的*类型*是否相等。
        * `!=`(不相等) 和 `!==`(*不严格相等*)
        * *JS对象的比较*是*引用的比较*，而不是值的比较。对象和其本身是相等的，但和其他任何对象都不相等。 （数组是特殊对象， 也是引用比较）
    2. 比较运算符
        * `< / > / <= / >=， 小于 大于 小于等于 大于等于`
        * 只有数字和字符串才能执行比较操作， 所以其他类型都将做类型转换
        * 字符串一次比较每个字符的 `Unicode字符编码顺序`。 
    3. `in`运算符
        * 左操作数是否是右操作数的属性名
    4. `instanceof`运算符
        * 左操作数是对象， 右操作数是对象的类， 判断一个对象是否是一个类的实例。
        * **所有对象都是`Object`的实例**。（这个判断是会包含对“父类”的检测）
* 4.10 逻辑表达式
    * 逻辑运算符`&& 、 || 、 !`是对操作数进行布尔算术运算。
    1. 逻辑与（`&&`）
        * **真值** 和 **假值**。 （不是true 或者 false， 但可以转为布尔值）
        * 两个操作数都为true运算结果才位true。
        * `&&`有时候*不一定返回布尔值*。
        ```
        var o = {x:2}
        var p = null;
        a = o && o.x; // 得到2 ：o是真值， 因此返回值 o.x。
        a = p && p.x; // 得到null： p是假值， 所以不回去计算 p.x。
        ```
        * `&&` 的行为有时候称为*短路*。
        ```
        if(a == b) stop(); 
        (a == b) stop(); //同上
        ```
    2. 逻辑或（`||`）
        * 常用在函数体内， 用来给参数提供默认值。
        ```
        function copy(o, p) {
            p = p || {}; // 如果参数p没有传入任何对象， 则使用 {}
            ...
        }
        ```
    3. 逻辑非（`!`）
        * `||`运算符是一元运算符。
        * 它的目的是将一个布尔值进行求反。
        * 和`&&`与`||`运算符不同， `!`运算符*首先*将其操作数转为布尔值， 然后再对布尔值求反。
* 4.11 赋值表达式
    * JS使用`=`运算符来给变量或者属性赋值。
    * 带操作的赋值： `+= / -= ...`。
* 4.12 表达式计算
    * JS可以*解释运行*由JS源代码组成的字符串， 并产生一个值。
    * JS通过全局函数 `eval()`来完成。
    * `eval()`是一个函数， 但由于它已经被当成运算符来对待了。
* 4.13 其他运算符
    1. 三元运算符： `? :`
    2. `typeof` 运算符：
        * 返回表示操作数类型的一个字符串。
        ```
        x               typeof
        undefined       "undefined"
        null            "object"
        true 或false     "boolean"
        任意数字或NaN      "number"
        任意数组           "object"   // 注意数组是被当作对象， 没有 "array"。
        任意函数           "function" // 而函数虽然是特殊对象， 但被特殊对待了。
        ...
        ```
        * 尽管函数是对象的一种，但是 typeof 还是将函数特殊对待。
    3. `delete`运算符：
        * 用来删除对象属性或者数组元素。
        * 删除不仅仅是设置一个undefined值，`in`检测时也将不存在。
        * 删除成功返回true，失败返回false（一些内置核心属性不能删除）。
    4. `void`运算符：
        * void是一元运算符， 操作数会照常计算，但忽略计算结果并返回undefined。
        * 最常用在客户端的URL -- `javascript:URL`, 让URL忽略表达式的计算结果。
        * `<a href="javascript:void window.open();">打开一个新窗口</a>`
    5. 逗号运算符`,`：
        * `,` 是二元运算符， 它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。

## 第5章 语句
    * JS的语句是以分号结束。
    * 例如赋值和函数调用这些右副作用的表达式可以单独作为语句。
    * JS解释器是依照语句顺序依次执行的， 同时JS提供了语句和控制结构来改变默认执行顺序： 条件语句， 循环语句， 跳转语句。5
* 5.1 表达式语句
    * JS中最简单的语句。
    * 赋值语句。
    * delete 运算符一般作为语句使用。
    * 函数调用是表达式语句的另一个大类。
* 5.2 复合语句和空语句
    * 多条语句联合在一起形成**复合语句**。
    * 只需用*花括号*将多条语句括起来即可。
    * 语句块结尾不需要分号， 块中的原始语句必须以分号结束;
    * 语句块中的每一行都有缩进，这不是必须的，但可以增强可读性和理解。
    * 空语句： 单独一个分号来表示一条空语句。
* 5.3 声明语句
    * `var` 和 `function` 都是声明语句。
    * 声明语句本身什么也不做，但它有一个重要意义，通过创建变量和函数，可以更好的组织代码语义。
    * 1. `var`
        * 声明一个或者多个变量：
        * 如果var语句出现在函数提内，那么它定义的是一个*局部变量*，其作用域就是这个函数;
        * 如果在顶层代码中使用var语句，它声明的是*全局变量*，在整个JS程序中都是可见的。
        * var声明的变量是无法通过delete删除的。（TODO： 待验证，在浏览器控制台测试不是这样的。）
        * var语句中的变量没有指定初始化表达式，那么变量的初始值位undefined。
        * `for循环`或者`for/in循环`组成部分的变量声明也会*变量提前*。
    * 2. `function`
        * 两种定义写法：
            * 将表达式赋值给一个变量： `var f = function(x) { return x; }`
            * 含有变量名的语句： `function f(x) { return f; }`
        * 定义时函数体内的语句并不执行， 花括号是必须的（循环语句或其他语句是可以省略花括号的）。
        * 函数声明通常出现在JS代码的最顶曾， 也可以嵌套在其他函数体内。（嵌套时函数声明只能出现在所在嵌套函数的顶部， 也就是不能在 if语句、 while循环或其他语句内声明函数）。
        * 函数声明语句创建的变量是无法删除。
* 5.4 条件语句
    * 通过判断*指定表达式的值*来决定执行还是跳过某些语句。
    1. `if`语句是一种基本的*控制语句*。 两种写法。
        `if / else` 语句通过判断一个表达式的计算结果来选择执行两条分支中的一条。
        ```
        if (expression) 
            statement
        ```
        ```
        if (expression) 
            statement1
        else 
            statement2
        ```
    2. `else if`
        * `else if`语句并不是真正的JS语句，只不过是多条`if/else`语句连在一起时的惯用写法。
        ```
        if () {
            //
        } else if {
            //
        } else if {
            //
        } else {
            //
        }
        ```
    3. `switch`
        * 当所有的分支都依赖于同一个表达式的值时， `else if`并不是最佳的解决方案， `switch`正好可以。
        * `case`只是指明要执行的代码起点， 但是没有指明终点。
        * `break`语句可以跳出switch语句或循环语句。
        * `default:`标签其实可以放在switch语句内的任何地方， *放在末尾是最合理和最常用的写法*。
        ```
        switch(n) {
            case 1:
                //
                break;
            case 2:
                //
                break;
            default:
                //
                break;
        }
        ```
* 5.5 循环
    * 为了理解条件语句，可以把JS中的代码想像成一条条分支路径。
    * **循环语句**就是程序路径的一个贿赂，可以让一部分代码重复执行。
    * JS中右4种循环语句： `while、 do/while、 for、 for/in`。
    1. `while`
        * 每次循环表达式的值也不同是很重要的一点， 否则可能造成死循环。
        ```
        while (expression)
            statement
        ```
    2. `do/while`
        * 和wihle相似，只不过是在循环的尾部检测循环表达式，意味着循环体*至少会执行一次*。
        ```
        do
            statement 
        while (expression);
        ```
    3. `for`
        * 比`while`更加方便的循环控制结构。
        * initizlize表达式*只在循环开始之前执行一次*。
        * test表达式的结果来决定是否执行循环体。
        * 如果test位真值， 则执行循环体内的语句， 最后执行increment表达式。
        * for循环中的那三个表达式中的任何一个都是可以忽略的，但是两个分号必不可少`for(;;)`。
        * 如果省略test表达式， 那么这将是一个*死循环*。
        ```
        for(initialize; test; increment)
            statement;
        ```
        * 等价于`while`如下写法
        ```
        initialize;
        while(test) {
            statement;
            increment;
        }
        ```
    4. `for/in`
        ```
        for (variable in object)
            statement;
        ```
        * for循环来**遍历数组元素**
        ```
        for(var i=0; i< a.length; i++)
            console.log(a[i]);
        ```
        * for/in循环则是方便**遍历对象属性**
        * 如果object表达式位null或者undefined，会跳过循环。
        ```
        for(var p in o) // 将*属性名*赋值给变量 p
            console.log(o[p]);
        ```
        * for/in循环数组枚举数组索引， JS数组不过是一种特殊对象
        * for/in循环并不会遍历对象的所有属性，只有*可枚举*的属性才会被遍历到。(很多语言核心定义的内置方法、属性都是*不可枚举*的)
        * 代码中定义的*所有*属性和方法都是可枚举的。
        * 属性枚举的顺序：
            * EAMCScripe规范并没有制定for/in循环按照何种顺序来枚举属性。
            * 主流浏览器都是选定义的属性先被枚举。
* 5.6 跳转
    0. 简介
        * break 语句是跳转到循环或者其他语句的结束。
        * continue 语句是终止本次循环的执行并开始下一次循环的执行。
        * 语句可以命名或带有标签， break和continue可以标识目标循环或者其他语句标签。
        * return 语句可以跳出函数体的执行，并提供本次调用的返回值。
        * throw 语句可以出发或者“抛出”一个异常，与try/catch/finally语句一起使用的，这些语句指定了处理异常的代码逻辑。（这个异常处理程序可以在同一个函数中或者更高层的调用栈中）
    1. 标签语句（很少用）
        * 语句是可以添加*标签*的，标签是由*语句前的标识符和冒号组成*。
        * `identifier: statement`
        * 通过给语句定义标签，就可以在程序的任何地方通过*标签名*引用这条语句。
        * 通过标签名可以在循环体内部使用break和continue来退出循环或者直接跳转到下一个循环的开始。
        * break和continue是唯一可以使用语句标签的语句。
        * 例子
        ```
        mainloop: while (token != null) {
            //
            continue mainloop;
            //
        }
        ```
    2. `break`语句
        * 单独使用break语句的作用是立即退出最内层的循环或switch语句。 `break;`
        * 同样允许break关键字后面跟随一个语句标签。
        * 无论break语句带不带标签，它的控制权都无法越过函数的边界。
    3. `continue`语句
        * continue语句和break语句非常类似，但它不是退出循环，而是转而执行下一次循环。
        * 不管continue语句带不带标签，它*只能在循环体内使用*。否则报语法错误。
    4. `return`语句
        * 函数中的return语句就是指定函数调用后的返回值。
        * return *只能在函数体内出现*。
        * return 没有带expression的话返回`undefined`。
    5. `throw`语句
        * 所谓异常是当发生了某种异常情况或错误时产生的一个信号。
        * 抛出异常，就是用信号通知发生了错误或异常状态。
        * 捕获异常，指的是处理这个信号，必须采取手段从异常中回复。
        * `try/catch/finally`语句可以捕捉异常。
        * `throw expression`;
        * 抛出异常的时候通常使用Error类型和其子类性：
        ```
        function factorial(x) {
            if (x < 0) throw new Error("x不能是附属");
            ...
        }
        ```
        * 抛出异常时JS解释器会立即停止当前正在执行的逻辑，并跳转至*就近*的异常处理程序。
        * 异常会沿着JS方法的此法结构和调用栈向上传播，如果没有找到任何异常处理程序，JS将会把异常当成程序错误来处理，并报告给用户。
    6. `try/catch/finally`语句
        * 处理异常机制的语句。
        * 当`try`块内某处发生了异常时，调用`catch`内的代码逻辑，不管是否产生异常`finally`块内的逻辑总是会执行。
        ```
        try {
            // 有时会抛出一个异常，要么是throw语句直接抛出异常， 要么是通过调用一个方法间接抛出异常
        } catch (e) {
             // 局部表量e获得对Error对象或者抛出的其他值的引用
        } finally {
            // 总会执行
        }
        * `catch / finally`是可选的，如果没有`catch从句`会先执行finally中的逻辑，然后向上传播这个异常，直到能找到处理这个异常的catch从句。
        * 如果finally从句抛出一个异常，这个异常将会代替正在抛出的异常。
        * 如果finally从句运行到了return语句，尽管已经抛出了异常且这个异常还没有出里，但是这个放那该法依然会正常返回。
* 5.7 其他语句类型
* 5.8 JavaScript语句小结


## 第6章 对象
* 6.1 创建对象
* 6.2 属性的查询和设置
* 6.3 删除属性
* 6.4 检测属性
* 6.5 枚举属性
* 6.6 属性getter和setter
* 6.7 属性的特性
* 6.8 对象的三个属性
* 6.9 序列化对象
* 6.10 对象方法


## 第7章 数组
* 7.1 创建数组
* 7.2 数组元素的读和写
* 7.3 稀疏数组
* 7.4 数组长度
* 7.5 数组元素的添加和删除
* 7.6 数组遍历
* 7.7 多维数组
* 7.8 数组方法
* 7.9 ECMAScript 5中的数组方法
* 7.10 数组类型
* 7.11 类数组对象
* 7.12 作为数组的字符串


## 第8章 函数
* 8.1 函数定义
* 8.2 函数调用
* 8.3 函数的实参和形参
* 8.4 作为值的函数
* 8.5 作为命名空间的函数
* 8.6 闭包
* 8.7 函数属性、方法和构造函数
* 8.8 函数式编程


## 第9章 类和模块
* 9.1 类和原型
* 9.2 类和构造函数
* 9.3 JavaScript中Java式的类继承
* 9.4 类的扩充
* 9.5 类和类型
* 9.6 JavaScript中的面向对象技术
* 9.7 子类
* 9.8 ECMAScript 5 中的类
* 9.9 模块


## 第10章 正则表达式的模式匹配
* 10.1 正则表达式的定义
* 10.2 用于模式匹配的String方法
* 10.3 RegExp对象


## 第11章 JavaScript的子集和扩展
* 11.1 JavaScript的子集
* 11.2 常量和局部变量
* 11.3 解构赋值
* 11.4 迭代
* 11.5 函数简写
* 11.6 多catch 从句
* 11.7 E4X: ECMAScript for XML


## 第12章 服务器端JavaScript
* 12.1 用Rhino脚本化Java
* 12.2 用Node实现异步I/O
