gofmt
godoc

## 包名
* 应为其源码目录的基本名称.在 `src/pkg/encoding/base64` 中的包应作为 `encoding/base64` 导入, 其包名应为 base64,  __而非__ `encoding_base64` 或 `encodingBase64`

* bufio 包中的缓存读取器类型叫做 Reader 而非 BufReader, bufio.Reader 不会与 io.Reader 发生冲突

* 简而言之, 目录不要超过2层


## 获取器和设置器
* 获取器: 若你有个名为 owner (小写, 未导出)的字段, 其获取器应当名为 Owner(大写, 可导 出)而非 GetOwner;
* 设置器: SetOwner;


## 接口名
* 按照约定, __只包含一个方法的接口__ 应当以该方法的名称加上 - er 后缀来命名, 如 Reader、 Writer、 Formatter、CloseNotifier 等

* Read、Write、 Close、Flush、 String 等都具有典型的签名和意义.为避免冲突, 请不要用这些名称为你的 方法命名,  除非你明确知道它们的签名和意义相同.

* 驼峰记法: Go 中约定使用驼峰记法 MixedCaps 或 mixedCaps;


## 控制结构
* 警告:无论如何, 你都不应将一个控制结构(if、for、switch 或 select)的左大括号放在下一行;

* 包含类型选择和多路通信复用器的新控制结构:select.

* 若 if 语句不会执行到下一条语句时(以 break、 continue、goto 或 return 结束时), 省略不必要的 else;


## 重新声明与再次赋值
* 常见错误: "No new variables on left side of :="


## for [range]
* 对于字符串, range 能够提供更多便利.它能通过解析 UTF-8,  将每个独立的 Unicode 码点 分离出来.错误的编码将占用一个字节, 并以符文 U+FFFD 来代替.
```go
for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```


## switch
* switch 并不会自动下溯, case 可通过逗号分隔来列举相同的处理条件

* 若 switch 后面没有表达式, 它将匹配 true, 因此, 我们可以将 if-else-if- else 链写成一个 switch
```go
a :=1
switch { // 此处没有表达式
case a<0:
    fmt.Println("a<0")
case a>0:
    fmt.Println("a>0")
case a==1: // 满足上面case则不会继续执行, 无需break
    fmt.Println("a==0")
default:
    fmt.Println("default")
}
``` 

## 类型选择 
* t.(type)

* switch 也可用于判断接口变量的动态类型
```go
i := 1
var t interface{}
t = &i
switch t := t.(type) {
case bool:
    fmt.Printf("boolean %t\n", t) // t 是 bool 类型
case int:
    fmt.Printf("integer %d\n", t) // t 是 int 类型
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t 是 *bool 类型
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t 是 *int 类型
default:
    fmt.Printf("unexpected type %T", t) // %T 输出 t 是什么类型
}
```


## 函数
* 多返回值: 通常 error 放最后;

* 返回值可命名: 
    * 命名后, 一旦该函数开始执行, 它们就会被初始化为与其类型相应的 __零值__； 
    * 若该函数执行了一 条不带实参的 return 语句, 则结果形参的当前值将被返回.

* defer: 按照后进先出(LIFO)的顺序执行;
    * 被推迟函数的实参(如果该函数为方法则还包括接收者)在推迟执行时就会求值, 而不是在调用执行时才求值.

```go
// 先进后出, 保留运行时值
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d \n", i)
}

fmt.Println("main:")
```


* Go 提供了两种分配原语, 即内建函数 new 和 make

## new
* 是个用来分配内存的内建函数, 它不会初始化内存, 只会将内存置零;

## make
* 它只用于创建切片、 映射和信道, 返回一个已初始化的值;

* 三种类型本质上为引用数据类型, 它们在使用前必须初始化;



## 数组
* 特别地, 若将某个数组传入某个函数, 它将接收到该数组的一份副本而非指针.

* 数组的大小是其类型的一部分.类型 [10]int 和 [20]int 是不同的.


## 切片
* 切片通过对数组进行封装, 为数据序列提供了更通用、强大而方便的接口.

* 切片保存了对底层数组的引用, 若你将某个切片赋予另一个切片, 它们会 __引用__ 同一个数组.


## 映射
* 若试图通过映射中不存在的键来取值, 就会返回与该映射中项的类型对应的零值

* 区分某项是不存在还是其值为零值, 可以使用多重赋值的形式来分辨: `seconds, ok = timeZone[tz]`


## 打印
* 打印结构体:
    * %+v 会为结构体的每 个字段添上字段名;
    * %#v 将完全按照 Go 的语法打印值;

* 打印值的类型: %T;

* 打印字符串并带双引号: %q;

* 若想控制自定义类型的默认格式, 只需为该类型定义一个具有 `String() string` 签名的方法;
    * 请勿通过调用 `Sprintf` 来构造 `String` 方法, 因为它会无 限递归你的的 `String` 方法

* 三个点作为形参或实参:
    * ... 形参可指定具体的类型;
    * ... 写在 v 之后来告诉编译器将 v 视作一个实参列表, 否则 它会将 v 当做单一的切片实参来传递;

    ```go
    // 接受不定数量的 interface{} 作为形参, 而不是接受一个 []interface{} 类型作为形参;
    func Println(v ...interface{}) {    
        std.Output(2, fmt.Sprintln(v...)) // Output 接受形参 (int, string) 
    }
    ```


## init 函数
* 其实每个文件都可以拥有多个 init 函数;

* 什么时候调用?
    * 1.只有该包中的所有变量声明都通过它们的初始化器求值后 init 才会被调用, 而那些 init 只有在所有已导入的包都 被初始化后才会被求值. (TODO: 不太明白)
    * 2.除了那些不能被表示成声明的初始化外, init 函数还常被用在程序真正开始执行前, 检验或校 正程序的状态.


## 方法: 指针 vs. 值
* 可以为任何已命名的类型（除了指针或接口）定义方法; 接收者可不必为结构体.

* 指针或值为接收者的区别在于: __值方法__ 可通过指针和值调用,  __指针方法__ 只能通过指针来调用.
    * 之所以会有这条规则是因为 __指针方法__ 可以修改接收者;
    * 通过 __值调用__ 它们会导致方法接收到该值的副本, 因此任何修改都将被丢弃, 因此该语言不允许这种错误;
    * 不过有个方便的例外: 若该值是可寻址的,  那么该语言就会自动插入取址操作符来对付一般的通过值调用的指针方法. (例如: 变量 b 是可寻址的, 通过 b.Write 调用, 编译器会将它重写为 (&b).Write)



## 接口
* 每种类型都能实现多个接口;


## 类型转换


## 接口转换与类型断言
* __类型选择__ 是类型转换的一种形式: 它接受一个 __接口__, 在选择(switch)中根据其判断选择对应的情况(case), 并在某种意义上将其转换为该种类型. (案例见上面)

* 也就是说, 只有接口(interface{})才有断言的操作?

* 已知是唯一的某种类型: `val := value.(typeName)`
    * 但是万一转换失败程序会崩溃, 那么使用 `val, ok := value.(typeName)` 来判断该值的类型是否为 typeName;
    * 若类型断言失败, val 将 __继续存在__ 且为 typeName 类型, 但它将拥有零值;


## 接口的通用性 -- TODO: 费解且重要
* 若某种现有的类型仅实现了一个接口, 且除此之外并无可导出的方法, 则该类型本身就无需 导出. 仅导出该接口能让我们更专注于其行为而非实现, 其它属性不同的实现则能镜像该原始类型的行为. 这也能够避免为每个通用接口的实例重复编写文档.

* 在这种情况下, __构造函数应当返回一个接口值__ 而非实现的类型.例如在 hash 库中,  crc32.NewIEEE() 和 adler32.New() 都返回接口类型 hash.Hash32.要在 Go 程序中用 Adler-32 算法替代 CRC-32,  只需修改构造函数调用即可, 其余代码则不受算法改变的影响.

* 通俗理解: 鸭子类型用来做返回值. (而以前一直把鸭子类型局限于作为参数)


## 接口和方法: 
* 由于几乎任何类型都能添加方法, 因此几乎任何类型都能满足一个接口
    * 一个很直观的例子就是 http 包中定义的 Handler 接口.任何实现了 Handler 的对象都能够处理 HTTP 请求.

* 既然我们可以为除指针和接口以外的任何类型定义方法, 同样也 能为一个函数写一个方法:
```go
// HandlerFunc 类型是一个适配器, 它允许将普通函数用做 HTTP 处理程序. 
// 若 f 是个具有适当签名的函数, HandlerFunc(f) 就是个调用 f 的处理程序对象. 
type HandlerFunc func(ResponseWriter, *Request) 

// ServeHTTP calls f(c, req). 
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { 
    f(w, req) 
}
```

* TODO:重要章节, 过看两遍 -- 在本节中, 我们通过一个结构体, 一个整数, 一个信道和一个函数, 建立了一个 HTTP 服务 器,  这一切都是因为接口只是方法的集和, 而几乎任何类型都能定义方法.


## 空白标识符
* 空白标识符可被赋予或声明为任何类 型的任何值，而其值会被无害地丢弃。

* 忽略错误而丢弃错误值的代码，这是种 __糟糕的实践__ (一定不能忽略错误)

* tip: `_ = fd` 假设fd是某个返回值, 但是暂时没用, 又怕遗忘, 可这么写.


## 接口检查
* 判断某个类型是否是实现了某个接口: `_, ok := val.(json.Marshaler);`

* TODO: 有些没太看懂


## 内嵌


## 并发
### 1. 通过通信共享内存
* Go 语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。 

* 在任意给定的时间点，只有一个 Go 程能够访问该值。 __数据竞争从设计上就被杜绝了__。

* __不要通过共享内存来通信，而应通过通信来共享内存。__

> 我们可以从典型的单线程运行在单 CPU 之上的情形来审视这种模型。它无需提供同步原语。 现在考虑另一种情况，它也无需同步。现在让它们俩进行通信。若将通信过程看做同步着， 那就完全不需要其它同步了。例如，Unix 管道就与这种模型完美契合。 尽管 Go 的并发处理 方式来源于 Hoare 的通信顺序处理（CSP）， 它依然可以看做是类型安全的 Unix 管道的实 现

### 2. Go 程 (Goroutines)
* 称之为 Go程 是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义

* Go程 具有简单的模型：它是与其它 Go程 并发运行在同一地址空间的函数。

* 它是轻量级的，所有小号几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价，仅在需要时 才会随着堆空间的分配（和释放）而变化。

* Go程 在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 I/O， 那么其 它的线程就会运行。

* 在 Go 中，函数字面都是闭包：其实现在 __保证了__ 函数内引用变量的生命周期与函数的活动时间 相同。

### 3. 信道
* 信道与映射一样，也需要通过 make 来分配内存。其结果值充当了对底层数据结构的 __引用__。 (引用类型)

* 带缓冲和不带缓冲

* 接收者在收到数据前会一直阻塞:
    * 若信道是不带缓冲的，那么在接收者收到值前，发送者会 一直阻塞；
    * 若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 
    * 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。


### 4. 信道中的信道
* Go 最重要的特性就是信道是 __一等值__，它可以被分配并像其它值到处传递。 这种特性通常被用 来实现安全、并行的多路分解。

> 要使其实际可用还有很多工作要做，这些代码仅能实现一个速率有限、并行、非阻塞 RPC 系 统的 框架，而且它 __并不包含互斥锁__。


### 5. 并行化
* 在多 CPU 核心上实现并行计算

* 如果计算过程能够被分为几块 可 独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。

> 目前 Go 运行时的实现 __默认不会并行执行代码__，它只为用户层代码提供单一的处理核心。 任意数量的 Go 程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代 码。 它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望 CPU 并行执行， 就必须告诉运行时你希望同时有多少 Go 程能执行代码。有两种途径可意识形态，要么在运行你的工作时将 GOMAXPROCS 环境变量设为你要使用的核心数， 要么导入 runtime 包并调用 runtime.GOMAXPROCS(NCPU)。 runtime.NumCPU() 的值可能很有用，它会返回当前机器的逻辑 CPU 核心数。 当然，随着调度算法和运行时的改进，将来会不再需要这种方法。

> 注意不要混淆 __并发和并行__ 的概念：__并发__ 是用可独立执行的组件构造程序的方法， 而 __并行__ 则是 为了效率在多 CPU 上平行地进行计算。尽管 Go 的并发特性能够让某些问题更易构造成并行计算， 但 Go 仍然是种并发而非并行的语言，且 Go 的模型并不适合所有的并行问题。


## 错误 Errors
* 自定义 error, 实现内建的 error 接口即可

* 若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误: 
    * eg `if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC { ... }`


## Panic
* 如果错误时不可恢复的呢？有时程序 __就是不能(不允许?)继续运行__。

* 内建的 panic 函数，它会产生一个运行时错误并终止程序;

* 实际的库函数应避免 panic;


## 恢复 Recover
* 当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序 将立刻终止当前函数的执行，并开始回溯 Go 程的栈，运行任何被推迟的函数。

* 若回溯到达 Go 程栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新或来取回 Go程 的控制权限并使其恢复正常执行。

* 调用 recover 将停止回溯过程，并返回传入 panic 的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此 recover 只能在被推迟(defer)的函数中才有效.

* regexp 包的理想化 版本，它会以局部的错误类型调用 panic 来报告解析错误:
```go
// Error 是解析错误的类型，它满足 error 接口。
type Error string

func (e Error) Error() string {
    return string(e)
}

// error 是 *Regexp 的方法，它通过用一个 Error 触发 Panic 来报告解析错误
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile 返回该正则表达式解析后的表示
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // 清理返回值。
            err = e.(Error) // 若它不是解析错误，将重新触发 Panic。(TODO: 重点)
        }
    }()
}
```
