## 读写锁
* 百科: 读写锁实际是一种特殊的自旋锁，它把 __对共享资源的访问者划分成读者和写者__，__读者__ 只对共享资源进行读访问，__写者__ 则需要对共享资源进行写操作。

* 介绍: 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。

* 读写锁：获取读写锁用于读和获取读写锁用于写作区分。


### 读写锁分配规则： https://blog.csdn.net/qaz5210987/article/details/79311114
1. 读锁：__共享锁__，此时可以有多个读锁，但是没有写锁。

2. 写锁：__独占锁__，此时在也没有任何的写/读锁。(TODO: 此时不就是互斥锁？？？)

3. 读写锁中，写锁优先抢占资源。


### https://www.cnblogs.com/chen--biao/p/11366952.html
* 重点: 
    1. 读锁共享;
    2. 写锁互斥;
    3. 读写锁互;

* __锁降级__: 将写锁降级为读锁。（先获取写锁，再获取读锁，再释放写锁，最后释放读锁）
    * 造成锁降级的原因: 出于性能考虑，一般情况下，都将锁定的动作，精确到具体的语句块，在两个锁的语句块之间，有可能线程的交替执行，造成线程安全问题。

    * 解决的方法:
        1. 将锁的范围扩大。
        2. 使用锁降级。

* 为什么需要锁降级: TODO: 没看懂伪代码
```go
// 伪代码：
    w.lock();       // 写锁
    writeSomeDate();// 修改某些数据
    w.unlock();     // 释放写锁
 
    r.lock();       // 读锁
    readSomeDate(); // 获取某个数据
    r.unlock();     // 释放读锁
// 此时，获取数据的时候，就有线程安全问题。 TODO: 为啥？？？
 
 
// 修改后的代码为：
    w.lock();       // 写锁
    writeSomeDate();// 修改某些数据
    r.lock();       // 读锁
    w.unlock();     // 释放写锁
    readSomeDate(); // 获取某个数据
    r.unlock();     // 释放读锁
// 将读锁的锁定动作，放入到写锁的释放之前，就可以将锁降级为读锁。
```
