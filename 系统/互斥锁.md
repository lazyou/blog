## 互斥锁（mutex lock）
* 百科：在编程中，引入了对象互斥锁的概念，来 __保证共享数据操作的完整性__。每个对象都对应于一个可称为 __"互斥锁" 的标记（bool）__，这个标记 __用来保证在任一时刻，只能有一个线程访问该对象__。


* 互斥锁：试图进入临界区的所有其他进程都阻塞住。



### http://c.biancheng.net/view/1231.html
* 采用互斥锁保护临界区，从而 __防止竞争条件__。也就是说，一个进程在进入临界区时应得到锁；它在退出临界区时释放锁。函数 acquire() 获取锁，而函数 release() 释放锁。

* 每个互斥锁有一个布尔变量 available，它的值表示锁是否可用。如果锁是可用的，那么调用 acquire() 会成功，并且锁不再可用。当一个进程试图获取不可用的锁时，它会阻塞，直到锁被释放。


### https://www.jianshu.com/p/82e9c6a0123f
* 一个或者多个操作在CPU执行的过程中不被中断的特性，称为 __原子性__。注意，原子性是面向cpu指令级别操作的，而不是面向高级语言操作。
    * TODO: 那高级语言实现的不是吗？

* 带来原子性问题的是 __线程切换__，如果能够禁用线程切换，那就能够解决原子性问题。而操作系统做线程切换是依赖CPU中断的，所以禁止CPU发生中断就能够禁止线程切换。
    * 这个方案，在单核CPU时代的确是可行的，而且也有很多应用案例，但是 __并不适合多核CPU场景__。

* 在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在CPU-1上，一个线程执行在CPU-2上，此时禁止CPU中断，只能保证CPU上的线程连续执行，__并不能保证同一时刻只有一个线程执行__，如果这两个线程同时写long型变量高32位的话，那就有可能出现bug了。

* 锁是一种通用的技术方案，Java语言提供的synchronized关键字，就是锁的一种实现。
    * synchronized关键字可以用来修饰方法，也可以用来修饰代码块，但是他没有显示的加锁lock()和解锁unlock()操作，这两个操作是被Java默默加上的，Java编译器会在synchronized修饰的方法或者代码块前后自动加上加锁lock()和解锁unlock()，这样做的好处就是加锁lock()和解锁unlock()一定是成对出现的，毕竟忘记解锁unlock()可是一个致命的bug。
