## 《现代操作系统》 目录
```
第1章　引论	1
1.1　什么是操作系统	2
1.1.1　作为扩展机器的操作系统	2
1.1.2　作为资源管理者的操作系统	3
1.2　操作系统的历史	4
1.2.1　第一代（1945～1955）：真空管和穿孔卡片	4
1.2.2　第二代（1955～1965）：晶体管和批处理系统	4
1.2.3　第三代（1965～1980）：集成电路和多道程序设计	6
1.2.4　第四代（1980年至今）：个人计算机	8
1.2.5　第五代（1990年至今）：移动计算机	10
1.3　计算机硬件简介	11
1.3.1　处理器	12
1.3.2　存储器	14
1.3.3　磁盘	15
1.3.4　I/O设备	16
1.3.5　总线	18
1.3.6　启动计算机	19
1.4　操作系统大观园	20
1.4.1　大型机操作系统	20
1.4.2　服务器操作系统	20
1.4.3　多处理器操作系统	20
1.4.4　个人计算机操作系统	20
1.4.5　掌上计算机操作系统	21
1.4.6　嵌入式操作系统	21
1.4.7　传感器节点操作系统	21
1.4.8　实时操作系统	21
1.4.9　智能卡操作系统	21
1.5　操作系统概念	22
1.5.1　进程	22
1.5.2　地址空间	23
1.5.3　文件	23
1.5.4　输入/输出	25
1.5.5　保护	25
1.5.6　shell	25
1.5.7　个体重复系统发育	26
1.6　系统调用	28
1.6.1　用于进程管理的系统调用	31
1.6.2　用于文件管理的系统调用	32
1.6.3　用于目录管理的系统调用	32
1.6.4　各种系统调用	34
1.6.5　Windows Win32 API	34
1.7　操作系统结构	35
1.7.1　单体系统	36
1.7.2　层次式系统	36
1.7.3　微内核	37
1.7.4　客户端–服务器模式	38
1.7.5　虚拟机	39
1.7.6　外核	41
1.8　依靠C的世界	41
1.8.1　C语言	41
1.8.2　头文件	41
1.8.3　大型编程项目	43
1.8.4　运行模型	43
1.9　有关操作系统的研究	44
1.10　本书其他部分概要	45
1.11　公制单位	45
1.12　小结	46
习题	46
第2章　进程与线程	48
2.1　进程	48
2.1.1　进程模型	48
2.1.2　进程的创建	49
2.1.3　进程的终止	51
2.1.4　进程的层次结构	51
2.1.5　进程的状态	51
2.1.6　进程的实现	53
2.1.7　多道程序设计模型	54
2.2　线程	54
2.2.1　线程的使用	54
2.2.2　经典的线程模型	57
2.2.3　POSIX线程	60
2.2.4　在用户空间中实现线程	60
2.2.5　在内核中实现线程	63
2.2.6　混合实现	63
2.2.7　调度程序激活机制	64
2.2.8　弹出式线程	64
2.2.9　使单线程代码多线程化	65
2.3　进程间通信	67
2.3.1　竞争条件	67
2.3.2　临界区	68
2.3.3　忙等待的互斥	68
2.3.4　睡眠与唤醒	71
2.3.5　信号量	73
2.3.6　互斥量	74
2.3.7　管程	78
2.3.8　消息传递	81
2.3.9　屏障	82
2.3.10　避免锁：读–复制–更新	83
2.4　调度	84
2.4.1　调度简介	84
2.4.2　批处理系统中的调度	88
2.4.3　交互式系统中的调度	89
2.4.4　实时系统中的调度	92
2.4.5　策略和机制	93
2.4.6　线程调度	93
2.5　经典的IPC问题	94
2.5.1　哲学家就餐问题	94
2.5.2　读者–写者问题	96
2.6　有关进程与线程的研究	97
2.7　小结	97
习题	98
第3章　内存管理	102
3.1　无存储器抽象	102
3.2　一种存储器抽象：地址空间	104
3.2.1　地址空间的概念	104
3.2.2　交换技术	106
3.2.3　空闲内存管理	107
3.3　虚拟内存	109
3.3.1　分页	110
3.3.2　页表	112
3.3.3　加速分页过程	112
3.3.4　针对大内存的页表	114
3.4　页面置换算法	117
3.4.1　最优页面置换算法	117
3.4.2　最近未使用页面置换算法	118
3.4.3　先进先出页面置换算法	118
3.4.4　第二次机会页面置换算法	118
3.4.5　时钟页面置换算法	119
3.4.6　最近最少使用页面置换算法	119
3.4.7　用软件模拟LRU	120
3.4.8　工作集页面置换算法	121
3.4.9　工作集时钟页面置换算法	123
3.4.10　页面置换算法小结	124
3.5　分页系统中的设计问题	124
3.5.1　局部分配策略与全局分配策略	124
3.5.2　负载控制	126
3.5.3　页面大小	126
3.5.4　分离的指令空间和数据空间	127
3.5.5　共享页面	128
3.5.6　共享库	128
3.5.7　内存映射文件	130
3.5.8　清除策略	130
3.5.9　虚拟内存接口	130
3.6　有关实现的问题	131
3.6.1　与分页有关的工作	131
3.6.2　缺页中断处理	131
3.6.3　指令备份	132
3.6.4　锁定内存中的页面	132
3.6.5　后备存储	133
3.6.6　策略和机制的分离	134
3.7　分段	134
3.7.1　纯分段的实现	136
3.7.2　分段和分页结合：MULTICS	136
3.7.3　分段和分页结合：Intel x86	138
3.8　有关内存管理的研究	141
3.9　小结	141
习题	142
第4章　文件系统	147
4.1　文件	148
4.1.1　文件命名	148
4.1.2　文件结构	149
4.1.3　文件类型	149
4.1.4　文件访问	151
4.1.5　文件属性	151
4.1.6　文件操作	152
4.1.7　使用文件系统调用的一个示例程序	152
4.2　目录	154
4.2.1　一级目录系统	154
4.2.2　层次目录系统	154
4.2.3　路径名	154
4.2.4　目录操作	156
4.3　文件系统的实现	157
4.3.1　文件系统布局	157
4.3.2　文件的实现	157
4.3.3　目录的实现	160
4.3.4　共享文件	162
4.3.5　日志结构文件系统	163
4.3.6　日志文件系统	164
4.3.7　虚拟文件系统	165
4.4　文件系统管理和优化	167
4.4.1　磁盘空间管理	167
4.4.2　文件系统备份	171
4.4.3　文件系统的一致性	174
4.4.4　文件系统性能	176
4.4.5　磁盘碎片整理	178
4.5　文件系统实例	179
4.5.1　MS-DOS文件系统	179
4.5.2　UNIX V7文件系统	181
4.5.3　CD-ROM文件系统	182
4.6　有关文件系统的研究	185
4.7　小结	185
习题	186
第5章　输入/输出	189
5.1　I/O硬件原理	189
5.1.1　I/O设备	189
5.1.2　设备控制器	190
5.1.3　内存映射I/O	190
5.1.4　直接存储器存取	192
5.1.5　重温中断	194
5.2　I/O软件原理	196
5.2.1　I/O软件的目标	196
5.2.2　程序控制I/O	197
5.2.3　中断驱动I/O	198
5.2.4　使用DMA的I/O	199
5.3　I/O软件层次	199
5.3.1　中断处理程序	199
5.3.2　设备驱动程序	200
5.3.3　与设备无关的I/O软件	202
5.3.4　用户空间的I/O软件	205
5.4　盘	206
5.4.1　盘的硬件	206
5.4.2　磁盘格式化	211
5.4.3　磁盘臂调度算法	213
5.4.4　错误处理	215
5.4.5　稳定存储器	216
5.5　时钟	218
5.5.1　时钟硬件	218
5.5.2　时钟软件	219
5.5.3　软定时器	221
5.6　用户界面：键盘、鼠标和监视器	222
5.6.1　输入软件	222
5.6.2　输出软件	225
5.7　瘦客户机	235
5.8　电源管理	236
5.8.1　硬件问题	236
5.8.2　操作系统问题	237
5.8.3　应用程序问题	241
5.9　有关输入/输出的研究	241
5.10　小结	242
习题	243
第6章　死锁	247
6.1　资源	247
6.1.1　可抢占资源和不可抢占资源	247
6.1.2　资源获取	248
6.2　死锁简介	249
6.2.1　资源死锁的条件	249
6.2.2　死锁建模	249
6.3　鸵鸟算法	251
6.4　死锁检测和死锁恢复	251
6.4.1　每种类型一个资源的死锁检测	252
6.4.2　每种类型多个资源的死锁检测	253
6.4.3　从死锁中恢复	254
6.5　死锁避免	255
6.5.1　资源轨迹图	255
6.5.2　安全状态和不安全状态	256
6.5.3　单个资源的银行家算法	257
6.5.4　多个资源的银行家算法	257
6.6　死锁预防	258
6.6.1　破坏互斥条件	258
6.6.2　破坏占有并等待条件	259
6.6.3　破坏不可抢占条件	259
6.6.4　破坏环路等待条件	259
6.7　其他问题	260
6.7.1　两阶段加锁	260
6.7.2　通信死锁	260
6.7.3　活锁	261
6.7.4　饥饿	262
6.8　有关死锁的研究	262
6.9　小结	263
习题	263
第7章　虚拟化和云	267
7.1　历史	268
7.2　虚拟化的必要条件	268
7.3　第一类和第二类虚拟机管理程序	270
7.4　高效虚拟化技术	271
7.4.1　在不支持虚拟化的平台上实现虚拟化	271
7.4.2　虚拟化的开销	273
7.5　虚拟机管理程序是正确的微内核吗	273
7.6　内存虚拟化	275
7.7　I/O虚拟化	277
7.8　虚拟装置	279
7.9　多核CPU上的虚拟机	279
7.10　授权问题	279
7.11　云	280
7.11.1　云即服务	280
7.11.2　虚拟机迁移	280
7.11.3　检查点	281
7.12　案例研究：VMware	281
7.12.1　VMware的早期历史	281
7.12.2　VMware Workstation	282
7.12.3　将虚拟化引入x86的挑战	282
7.12.4　VMware Workstation解决方案概览	283
7.12.5　VMware Workstation的演变	288
7.12.6　VMware的第一类虚拟机管理程序ESX Server	288
7.13　有关虚拟化和云的研究	289
习题	289
第8章　多处理机系统	291
8.1　多处理机	292
8.1.1　多处理机硬件	292
8.1.2　多处理机操作系统类型	298
8.1.3　多处理机同步	301
8.1.4　多处理机调度	303
8.2　多计算机	306
8.2.1　多计算机硬件	307
8.2.2　低层通信软件	309
8.2.3　用户层通信软件	311
8.2.4　远程过程调用	313
8.2.5　分布式共享存储器	314
8.2.6　多计算机调度	317
8.2.7　负载平衡	318
8.3　分布式系统	319
8.3.1　网络硬件	321
8.3.2　网络服务和协议	323
8.3.3　基于文档的中间件	325
8.3.4　基于文件系统的中间件	326
8.3.5　基于对象的中间件	329
8.3.6　基于协作的中间件	330
8.4　有关多处理机系统的研究	332
8.5　小结	332
习题	333
第9章　安全	336
9.1　环境安全	337
9.1.1　威胁	337
9.1.2　入侵者	339
9.2　操作系统完全	339
9.2.1　可信系统	339
9.2.2　可信计算基	340
9.3　保护机制	341
9.3.1　保护域	341
9.3.2　访问控制列表	342
9.3.3　权能字	344
9.4　安全系统的形式化模型	345
9.4.1　多级安全	346
9.4.2　隐蔽信道	348
9.5　密码学原理	350
9.5.1　私钥加密技术	351
9.5.2　公钥加密技术	351
9.5.3　单向函数	352
9.5.4　数字签名	352
9.5.5　可信平台模块	353
9.6　认证	354
9.6.1　使用物理识别的认证方式	358
9.6.2　使用生物识别的认证方式	360
9.7　软件漏洞	361
9.7.1　缓冲区溢出攻击	361
9.7.2　格式化字符串攻击	367
9.7.3　悬垂指针	369
9.7.4　空指针间接引用攻击	369
9.7.5　整数溢出攻击	370
9.7.6　命令注入攻击	370
9.7.7　检查时间/使用时间攻击	371
9.8　内部攻击	371
9.8.1　逻辑炸弹	371
9.8.2　后门陷阱	372
9.8.3　登录欺骗	372
9.9　恶意软件	373
9.9.1　特洛伊木马	374
9.9.2　病毒	375
9.9.3　蠕虫	381
9.9.4　间谍软件	382
9.9.5　rootkit	384
9.10　防御	386
9.10.1　防火墙	387
9.10.2　反病毒和抑制反病毒技术	388
9.10.3　代码签名	392
9.10.4　囚禁	392
9.10.5　基于模型的入侵检测	393
9.10.6　封装移动代码	394
9.10.7　Java安全性	396
9.11　有关安全的研究	397
9.12　小结	398
习题	398
第10章　实例研究1：UNIX、Linux和Android	403
10.1　UNIX与Linux的历史	403
10.1.1　UNICS	403
10.1.2　PDP-11 UNIX	404
10.1.3　可移植的UNIX	404
10.1.4　Berkeley UNIX	405
10.1.5　标准UNIX	405
10.1.6　MINIX	406
10.1.7　Linux	407
10.2　Linux简介	408
10.2.1　Linux的设计目标	408
10.2.2　到Linux的接口	409
10.2.3　shell	410
10.2.4　Linux应用程序	412
10.2.5　内核结构	413
10.3　Linux中的进程	414
10.3.1　基本概念	414
10.3.2　Linux中进程管理相关的系统调用	416
10.3.3　Linux中进程与线程的实现	418
10.3.4　Linux中的调度	422
10.3.5　启动Linux系统	425
10.4　Linux中的内存管理	426
10.4.1　基本概念	427
10.4.2　Linux中的内存管理系统调用	429
10.4.3　Linux中内存管理的实现	429
10.4.4　Linux中的分页	433
10.5　Linux中的I/O系统	434
10.5.1　基本概念	434
10.5.2　网络	435
10.5.3　Linux中的I/O系统调用	436
10.5.4　I/O在Linux中的实现	437
10.5.5　Linux中的模块	439
10.6　Linux文件系统	439
10.6.1　基本概念	439
10.6.2　Linux中的文件系统调用	442
10.6.3　Linux文件系统的实现	444
10.6.4　NFS：网络文件系统	449
10.7　Linux的安全性	452
10.7.1　基本概念	452
10.7.2　Linux中安全相关的系统调用	454
10.7.3　Linux中的安全实现	454
10.8　Android	455
10.8.1　Android与Google	455
10.8.2　Android的历史	455
10.8.3　设计目标	457
10.8.4　Android体系结构	458
10.8.5　Linux扩展	459
10.8.6　Dalvik	461
10.8.7　Binder IPC	462
10.8.8　Android应用	467
10.8.9　意图	475
10.8.10　应用程序沙箱	475
10.8.11　安全性	476
10.8.12　进程模型	479
10.9　小结	482
习题	483
第11章　实例研究2：Windows 8	487
11.1　Windows 8.1的历史	487
11.1.1　20世纪80年代：MS-DOS	487
11.1.2　20世纪90年代：基于MS-DOS的Windows	488
11.1.3　21世纪00年代：基于NT的Windows	488
11.1.4　Windows Vista	489
11.1.5　21世纪10年代：现代Windows	490
11.2　Windows 编程	490
11.2.1　原生NT应用编程接口	493
11.2.2　Win32应用编程接口	494
11.2.3　Windows注册表	496
11.3　系统结构	498
11.3.1　操作系统结构	498
11.3.2　启动Windows 506
11.3.3　对象管理器的实现	507
11.3.4　子系统、DLL和用户态服务	513
11.4　Windows中的进程和线程	514
11.4.1　基本概念	514
11.4.2　作业、进程、线程和纤程管理API调用	518
11.4.3　进程和线程的实现	521
11.5　内存管理	525
11.5.1　基本概念	525
11.5.2　内存管理系统调用	527
11.5.3　存储管理的实现	528
11.6　Windows的高速缓存	533
11.7　Windows的I/O	534
11.7.1　基本概念	534
11.7.2　I/O的API调用	535
11.7.3　I/O实现	536
11.8　Windows NT文件系统	539
11.8.1　基本概念	540
11.8.2　NTFS文件系统的实现	540
11.9　Windows电源管理	546
11.10　Windows 8中的安全	547
11.10.1　基本概念	548
11.10.2　安全相关的API调用	548
11.10.3　安全实现	549
11.10.4　安全缓解技术	551
11.11　小结	552
习题	553
第12章　操作系统设计	556
12.1　设计问题的本质	556
12.1.1　目标	556
12.1.2　设计操作系统为什么困难	557
12.2　接口设计	558
12.2.1　指导原则	558
12.2.2　范型	559
12.2.3　系统调用接口	561
12.3　实现	563
12.3.1　系统结构	563
12.3.2　机制与策略	565
12.3.3　正交性	566
12.3.4　命名	566
12.3.5　绑定的时机	567
12.3.6　静态与动态结构	567
12.3.7　自顶向下与自底向上的实现	568
12.3.8　同步通信与异步通信	568
12.3.9　实用技术	569
12.4　性能	572
12.4.1　操作系统为什么运行缓慢	572
12.4.2　什么应该优化	573
12.4.3　空间–时间的权衡	573
12.4.4　缓存	575
12.4.5　线索	575
12.4.6　利用局部性	576
12.4.7　优化常见的情况	576
12.5　项目管理	576
12.5.1　人月神话	576
12.5.2　团队结构	577
12.5.3　经验的作用	578
12.5.4　没有银弹	579
12.6　操作系统设计的趋势	579
12.6.1　虚拟化与云	579
12.6.2　众核芯片	580
12.6.3　大型地址空间操作系统	580
12.6.4　无缝的数据访问	580
12.6.5　电池供电的计算机	581
12.6.6　嵌入式系统	581
12.7　小结	581
习题	582
第13章　参考书目与文献	584
13.1　进行深入阅读的建议	584
13.1.1　引论	584
13.1.2　进程与线程	584
13.1.3　内存管理	585
13.1.4　文件系统	585
13.1.5　输入/输出	585
13.1.6　死锁	586
13.1.7　虚拟化和云	586
13.1.8　多处理机系统	586
13.1.9　安全	587
13.1.10　实例研究1：UNIX、Linux和Android	588
13.1.11　实例研究2：Windows 8	588
13.1.12　操作系统设计	589
13.2　按字母顺序排序的参考文献	589
```
